<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ldy&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-04-09T06:49:02.413Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ldy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2016/04/09/2016-04-09-Deepin%20CUDA%E5%AE%89%E8%A3%85%E5%8F%8AKeras%E4%BD%BF%E7%94%A8GPU%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C/"/>
    <id>http://yoursite.com/2016/04/09/2016-04-09-Deepin CUDA安装及Keras使用GPU模式运行/</id>
    <published>2016-04-09T06:49:02.413Z</published>
    <updated>2016-04-09T06:49:02.413Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Deepin-CUDA安装及Keras使用GPU模式运行&quot;&gt;&lt;a href=&quot;#Deepin-CUDA安装及Keras使用GPU模式运行&quot; class=&quot;headerlink&quot; title=&quot;Deepin CUDA安装及Keras使用GPU模式运行&quot;&gt;&lt;/a&gt;Deepin CUDA安装及Keras使用GPU模式运行&lt;/h2&gt;&lt;p&gt;layout:     post&lt;br&gt;title:      “Deepin CUDA安装及Keras使用GPU模式运行”&lt;br&gt;subtitle:   “Deepin CUDA安装及Keras使用GPU模式运行”&lt;br&gt;date:       2016-04-09 11:00:00&lt;br&gt;author:     “Ldy”&lt;br&gt;header-img: “img/tag-bg1.jpg”&lt;br&gt;tags:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Cuda
- Keras
- Deep Learning
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-4-9/8883646.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Deepin简介&quot;&gt;&lt;a href=&quot;#Deepin简介&quot; class=&quot;headerlink&quot; title=&quot;Deepin简介&quot;&gt;&lt;/a&gt;Deepin简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.deepin.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deepin&lt;/a&gt;是由武汉深之度科技有限公司开发的Linux发行版,Deepin 为所有人提供稳定、高效的操作系统，强调安全、易用、美观。其口号为“免除新手痛苦，节约老手时间”。&lt;/p&gt;
&lt;h1 id=&quot;cuda安装&quot;&gt;&lt;a href=&quot;#cuda安装&quot; class=&quot;headerlink&quot; title=&quot;cuda安装&quot;&gt;&lt;/a&gt;cuda安装&lt;/h1&gt;&lt;h2 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h2&gt;&lt;p&gt;安装系统的版本下载对应的cuda版本，下载地址：&lt;a href=&quot;https://developer.nvidia.com/cuda-downloads&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.nvidia.com/cuda-downloads&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;注意执行安装文件的时候一定要加上’–­­override’，不然会出现错误：’”Toolkit: Installation Failed. Using unsupported Compiler.”‘&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chmod 755 cuda_7.5.18_linux.run&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo ./cuda_7.5.18_linux.run --­­override&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你电脑里已经装好比cuda内置的NVIDIA驱动更新的版本，那么在安装的时候就要选择安装NVIDIA驱动。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装过程的设置如下所示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-------------------------------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Do you accept the previously read EULA? (accept/decline/quit): accept&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;You are attempting to install on an unsupported configuration. Do you wish to continue? ((y)es/(n)o) [ default is no ]: y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 352.39? ((y)es/(n)o/(q)uit): n&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Install the CUDA 7.5 Toolkit? ((y)es/(n)o/(q)uit): y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enter Toolkit Location [ default is /usr/local/cuda-7.5 ]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Do you want to install a symbolic link at /usr/local/cuda? ((y)es/(n)o/(q)uit): y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Install the CUDA 7.5 Samples? ((y)es/(n)o/(q)uit): y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enter CUDA Samples Location [ default is /home/kinghorn ]: /usr/local/cuda-7.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Installing the CUDA Toolkit in /usr/local/cuda-7.5 ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Finished copying samples.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===========&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;= Summary =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===========&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Driver:   Not Selected&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Toolkit:  Installed in /usr/local/cuda-7.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Samples:  Installed in /usr/local/cuda-7.5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;环境设置&quot;&gt;&lt;a href=&quot;#环境设置&quot; class=&quot;headerlink&quot; title=&quot;环境设置&quot;&gt;&lt;/a&gt;环境设置&lt;/h2&gt;&lt;p&gt;打开~/.bashrc&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;gedit ~/.bashrc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;添加下面两条语句：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export PATH=$PATH:/usr/local/cuda/bin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;强制cuda使用gcc-5&quot;&gt;&lt;a href=&quot;#强制cuda使用gcc-5&quot; class=&quot;headerlink&quot; title=&quot;强制cuda使用gcc 5&quot;&gt;&lt;/a&gt;强制cuda使用gcc 5&lt;/h2&gt;&lt;p&gt;因为cuda默认不使用gcc&amp;gt;4.8，通过注释掉报错行来强制使用gcc 5。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo gedit /usr/local/cuda/include/host_config.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//注释掉115行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//#error -- unsupported GNU version! gcc versions later than 4.9 are not supported!&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;运行cuda内置的例子&quot;&gt;&lt;a href=&quot;#运行cuda内置的例子&quot; class=&quot;headerlink&quot; title=&quot;运行cuda内置的例子&quot;&gt;&lt;/a&gt;运行cuda内置的例子&lt;/h2&gt;&lt;p&gt;为了测试是否安装成功&lt;/p&gt;
&lt;p&gt;进入内置例程&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cd /usr/local/cuda/samples/1_Utilities/deviceQuery&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;编译&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;make&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;./deviceQuery&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;得到结果：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CUDA Device Query (Runtime API) version (CUDART static linking)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Detected 1 CUDA Capable device(s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Device 0: &amp;quot;GeForce GT 520M&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; CUDA Driver Version / Runtime Version          8.0 / 7.5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; CUDA Capability Major/Minor version number:    2.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Total amount of global memory:                 1024 MBytes (1073414144 bytes)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ( 1) Multiprocessors, ( 48) CUDA Cores/MP:     48 CUDA Cores&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; GPU Max Clock rate:                            1480 MHz (1.48 GHz)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Memory Clock rate:                             800 Mhz&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Memory Bus Width:                              64-bit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; L2 Cache Size:                                 65536 bytes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Maximum Texture Dimension Size (x,y,z)         1D=(65536), 2D=(65536, 65535), 3D=(2048, 2048, 2048)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Maximum Layered 1D Texture Size, (num) layers  1D=(16384), 2048 layers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Maximum Layered 2D Texture Size, (num) layers  2D=(16384, 16384), 2048 layers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Total amount of constant memory:               65536 bytes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Total amount of shared memory per block:       49152 bytes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Total number of registers available per block: 32768&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Warp size:                                     32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Maximum number of threads per multiprocessor:  1536&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Maximum number of threads per block:           1024&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Max dimension size of a thread block (x,y,z): (1024, 1024, 64)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Max dimension size of a grid size    (x,y,z): (65535, 65535, 65535)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Maximum memory pitch:                          2147483647 bytes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Texture alignment:                             512 bytes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Concurrent copy and kernel execution:          Yes with 1 copy engine(s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Run time limit on kernels:                     No&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Integrated GPU sharing Host Memory:            No&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Support host page-locked memory mapping:       Yes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Alignment requirement for Surfaces:            Yes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Device has ECC support:                        Disabled&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Device supports Unified Addressing (UVA):      Yes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Device PCI Domain ID / Bus ID / location ID:   0 / 1 / 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; Compute Mode:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 8.0, CUDA Runtime Version = 7.5, NumDevs = 1, Device0 = GeForce GT 520M&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Result = PASS&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果编译出错，检查是否有强制设置gcc 5来编译；如果输出结果为fail，说明没有检查到显卡，解决方案是升级你的NVIDIA驱动，确保你电脑的NVIDIA驱动版本要不低于cuda的内置版本。&lt;/p&gt;
&lt;h1 id=&quot;设置Keras运行于GPU模式&quot;&gt;&lt;a href=&quot;#设置Keras运行于GPU模式&quot; class=&quot;headerlink&quot; title=&quot;设置Keras运行于GPU模式&quot;&gt;&lt;/a&gt;设置Keras运行于GPU模式&lt;/h1&gt;&lt;p&gt;我们运行Keras里的一个用于电影评论情感分析的例子&lt;a href=&quot;https://github.com/fchollet/keras/blob/master/examples/imdb_cnn.py&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;imdb_cnn.py&lt;/a&gt;,第一次运行时需要联网，要下载数据库。&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;This example demonstrates the use of Convolution1D for text classification.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Run on GPU: THEANO_FLAGS=mode=FAST_RUN,device=gpu,floatX=float32 python imdb_cnn.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Get to 0.835 test accuracy after 2 epochs. 100s/epoch on K520 GPU.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; __future__ &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; print_function&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;np.random.seed(&lt;span class=&quot;number&quot;&gt;1337&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;# for reproducibility&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.preprocessing &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sequence&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.models &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Sequential&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.layers.core &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Dense, Dropout, Activation, Flatten&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.layers.embeddings &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Embedding&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.layers.convolutional &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Convolution1D, MaxPooling1D&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.datasets &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; imdb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# set parameters:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;max_features = &lt;span class=&quot;number&quot;&gt;5000&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;maxlen = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;batch_size = &lt;span class=&quot;number&quot;&gt;32&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;embedding_dims = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nb_filter = &lt;span class=&quot;number&quot;&gt;250&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;filter_length = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hidden_dims = &lt;span class=&quot;number&quot;&gt;250&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nb_epoch = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&#39;Loading data...&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(X_train, y_train), (X_test, y_test) = imdb.load_data(nb_words=max_features,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                      test_split=&lt;span class=&quot;number&quot;&gt;0.2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(len(X_train), &lt;span class=&quot;string&quot;&gt;&#39;train sequences&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(len(X_test), &lt;span class=&quot;string&quot;&gt;&#39;test sequences&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&#39;Pad sequences (samples x time)&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X_train = sequence.pad_sequences(X_train, maxlen=maxlen)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X_test = sequence.pad_sequences(X_test, maxlen=maxlen)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&#39;X_train shape:&#39;&lt;/span&gt;, X_train.shape)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&#39;X_test shape:&#39;&lt;/span&gt;, X_test.shape)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&#39;Build model...&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model = Sequential()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# we start off with an efficient embedding layer which maps&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# our vocab indices into embedding_dims dimensions&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Embedding(max_features, embedding_dims, input_length=maxlen))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Dropout(&lt;span class=&quot;number&quot;&gt;0.25&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# we add a Convolution1D, which will learn nb_filter&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# word group filters of size filter_length:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Convolution1D(nb_filter=nb_filter,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        filter_length=filter_length,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        border_mode=&lt;span class=&quot;string&quot;&gt;&#39;valid&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        activation=&lt;span class=&quot;string&quot;&gt;&#39;relu&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        subsample_length=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# we use standard max pooling (halving the output of the previous layer):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(MaxPooling1D(pool_length=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# We flatten the output of the conv layer,&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# so that we can add a vanilla dense layer:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Flatten())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# We add a vanilla hidden layer:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Dense(hidden_dims))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Dropout(&lt;span class=&quot;number&quot;&gt;0.25&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Activation(&lt;span class=&quot;string&quot;&gt;&#39;relu&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# We project onto a single unit output layer, and squash it with a sigmoid:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Dense(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Activation(&lt;span class=&quot;string&quot;&gt;&#39;sigmoid&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.compile(loss=&lt;span class=&quot;string&quot;&gt;&#39;binary_crossentropy&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              optimizer=&lt;span class=&quot;string&quot;&gt;&#39;rmsprop&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.fit(X_train, y_train, batch_size=batch_size,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          nb_epoch=nb_epoch, show_accuracy=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          validation_data=(X_test, y_test))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h2&gt;&lt;p&gt; 使用如下命令行运行&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;THEANO_FLAGS=device=gpu,floatX=float32 python my_keras_script.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;方法二&quot;&gt;&lt;a href=&quot;#方法二&quot; class=&quot;headerlink&quot; title=&quot;方法二&quot;&gt;&lt;/a&gt;方法二&lt;/h2&gt;&lt;p&gt;设置$HOME/.theanorc文件&lt;/p&gt;
&lt;p&gt;添加如下所示文件&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[global]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;floatX = float32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;device = gpu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[lib]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cnmem = 0.9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[cuda]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root = /usr/local/cuda&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;方法三&quot;&gt;&lt;a href=&quot;#方法三&quot; class=&quot;headerlink&quot; title=&quot;方法三&quot;&gt;&lt;/a&gt;方法三&lt;/h2&gt;&lt;p&gt;在你的代码前面，加上如下所示文件：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; theano&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;theano.config.device = &lt;span class=&quot;string&quot;&gt;&#39;gpu&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;theano.config.floatX = &lt;span class=&quot;string&quot;&gt;&#39;float32&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行这个例子，在K520 GPU上是100s一次循环，我电脑显卡型号&lt;br&gt;为GeForce GT 520M，大概需要175s一次循环，不过比在cpu&lt;br&gt;上运行快多啦，在我这四年前的旧电脑的cpu上运行差不多要一个小时。&lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.pugetsystems.com/labs/articles/NVIDIA-CUDA-with-Ubuntu-16-04-beta-on-a-laptop-if-you-just-cannot-wait-775/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;    NVIDIA CUDA with Ubuntu 16.04 beta on a laptop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://keras.io/faq/#how-can-i-run-keras-on-gpu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keras FAQ&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Deepin-CUDA安装及Keras使用GPU模式运行&quot;&gt;&lt;a href=&quot;#Deepin-CUDA安装及Keras使用GPU模式运行&quot; class=&quot;headerlink&quot; title=&quot;Deepin CUDA安装及Keras使用GPU模式运行&quot;&gt;&lt;/a&gt;Deepin CUDA安装及Keras使用GPU模式运行&lt;/h2&gt;&lt;p&gt;layout:     post&lt;br&gt;title:      “Deepin CUDA安装及Keras使用GPU模式运行”&lt;br&gt;subtitle:   “Deepin CUDA安装及Keras使用GPU模式运行”&lt;br&gt;date:       2016-04-09 11:00:00&lt;br&gt;author:     “Ldy”&lt;br&gt;header-img: “img/tag-bg1.jpg”&lt;br&gt;tags:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Cuda
- Keras
- Deep Learning
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-4-9/8883646.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Keras简介</title>
    <link href="http://yoursite.com/2016/04/07/2016-04-07-Keras%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2016/04/07/2016-04-07-Keras简介/</id>
    <published>2016-04-07T03:00:00.000Z</published>
    <updated>2016-04-07T02:35:37.848Z</updated>
    
    <content type="html">&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-4-7/16129390.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h1 id=&quot;Keras-简介&quot;&gt;&lt;a href=&quot;#Keras-简介&quot; class=&quot;headerlink&quot; title=&quot;Keras 简介&quot;&gt;&lt;/a&gt;Keras 简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://keras.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keras&lt;/a&gt;是一个用Python编写的基于 TensorFlow 和 Theano高度模块化的神经网络库。其最大的优点在于样例丰富，现有主流模型封装完美。复杂点的模型可以像搭积木一样搞出来，适合快速地搭建模型。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;安装：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo pip install keras&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;Keras里的基本模块&quot;&gt;&lt;a href=&quot;#Keras里的基本模块&quot; class=&quot;headerlink&quot; title=&quot;Keras里的基本模块&quot;&gt;&lt;/a&gt;Keras里的基本模块&lt;/h1&gt;&lt;h2 id=&quot;optimizers&quot;&gt;&lt;a href=&quot;#optimizers&quot; class=&quot;headerlink&quot; title=&quot;optimizers&quot;&gt;&lt;/a&gt;optimizers&lt;/h2&gt;&lt;p&gt;Keras包含了很多优化方法。比如最常用的随机梯度下降法(SGD)，还有Adagrad、Adadelta、RMSprop、Adam等。下面通过具体的代码介绍一下优化器的使用方法。&lt;br&gt;在编译一个Keras模型时，优化器是2个参数之一（另外一个是损失函数）。看如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;model = Sequential()  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Dense(&lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;, init=&lt;span class=&quot;string&quot;&gt;&#39;uniform&#39;&lt;/span&gt;, input_dim=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;))  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Activation(&lt;span class=&quot;string&quot;&gt;&#39;tanh&#39;&lt;/span&gt;))  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Activation(&lt;span class=&quot;string&quot;&gt;&#39;softmax&#39;&lt;/span&gt;))  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sgd = SGD(lr=&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;, decay=&lt;span class=&quot;number&quot;&gt;1e-6&lt;/span&gt;, momentum=&lt;span class=&quot;number&quot;&gt;0.9&lt;/span&gt;, nesterov=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.compile(loss=&lt;span class=&quot;string&quot;&gt;&#39;mean_squared_error&#39;&lt;/span&gt;, optimizer=sgd)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个例子中是在调用compile之前实例化了一个优化器。我们也可以通过传递名字的方式调用默认的优化器。代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# passoptimizer by name: default parameters will be used  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.compile(loss=&lt;span class=&quot;string&quot;&gt;&#39;mean_squared_error&#39;&lt;/span&gt;, optimizer=&lt;span class=&quot;string&quot;&gt;&#39;sgd&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;SGD（随机梯度下降优化器，性价比最好的算法）&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;keras.optimizers.SGD(lr=&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;, momentum=&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;, decay=&lt;span class=&quot;number&quot;&gt;0.&lt;/span&gt;, nesterov=&lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lr :float&amp;gt;=0，学习速率&lt;/li&gt;
&lt;li&gt;momentum :float&amp;gt;=0 参数更新的动量&lt;/li&gt;
&lt;li&gt;decay : float&amp;gt;=0 每次更新后学习速率的衰减量&lt;/li&gt;
&lt;li&gt;nesterov :Boolean 是否使用Nesterov动量项&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;objectives&quot;&gt;&lt;a href=&quot;#objectives&quot; class=&quot;headerlink&quot; title=&quot;objectives&quot;&gt;&lt;/a&gt;objectives&lt;/h2&gt;&lt;p&gt;目标函数模块，keras提供了mean_squared_error，mean_absolute_error，squared_hinge，hinge，binary_crossentropy，categorical_crossentropy这几种目标函数。&lt;/p&gt;
&lt;p&gt;这里binary_crossentropy 和categorical_crossentropy也就是常说的logloss.&lt;/p&gt;
&lt;h2 id=&quot;Activations&quot;&gt;&lt;a href=&quot;#Activations&quot; class=&quot;headerlink&quot; title=&quot;Activations&quot;&gt;&lt;/a&gt;Activations&lt;/h2&gt;&lt;p&gt;激活函数模块，keras提供了linear、sigmoid、hard_sigmoid、tanh、softplus、relu、softplus，另外softmax也放在Activations模块里。此外，像LeakyReLU和PReLU这种比较新的激活函数，keras在keras.layers.advanced_activations模块里提供。&lt;/p&gt;
&lt;h2 id=&quot;initializations&quot;&gt;&lt;a href=&quot;#initializations&quot; class=&quot;headerlink&quot; title=&quot;initializations&quot;&gt;&lt;/a&gt;initializations&lt;/h2&gt;&lt;p&gt;权值初始化，在Keras中对权值矩阵初始化的方式很简单，就是在add某一层时，同时注明初始化该层的概率分布是什么就可以了。代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# init是关键字，’uniform’表示用均匀分布去初始化  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Dense(&lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;, init=&lt;span class=&quot;string&quot;&gt;&#39;uniform&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;keras提供了uniform、lecun_uniform、normal、orthogonal、zero、glorot_normal、he_normal这几种。&lt;/p&gt;
&lt;h2 id=&quot;regularizers&quot;&gt;&lt;a href=&quot;#regularizers&quot; class=&quot;headerlink&quot; title=&quot;regularizers&quot;&gt;&lt;/a&gt;regularizers&lt;/h2&gt;&lt;p&gt;深度学习容易出现过拟合，通过使用&lt;a href=&quot;http://blog.csdn.net/u012162613/article/details/44261657&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;正则化方法&lt;/a&gt;，防止过拟合，提高泛化能力。&lt;/p&gt;
&lt;p&gt;使用示例代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.regularizers &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; l2, activity_l2  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Dense(&lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;, input_dim=&lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;, W_regularizer=l2(&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;), activity_regularizer=activity_l2(&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;constraints&quot;&gt;&lt;a href=&quot;#constraints&quot; class=&quot;headerlink&quot; title=&quot;constraints&quot;&gt;&lt;/a&gt;constraints&lt;/h2&gt;&lt;p&gt;除了正则化外，Keras还有一个约束限制功能。函数可以设置在训练网络到最优时对网络参数的约束。这个约束就是限制参数值的取值范围。比如最大值是多少，不允许为负值等。&lt;/p&gt;
&lt;p&gt;2个关键的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;W_constraint：约束主要的权值矩阵&lt;/li&gt;
&lt;li&gt;b_constraint：约束偏置值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用示例代码如下：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.constraints &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; maxnorm&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Dense(&lt;span class=&quot;number&quot;&gt;64&lt;/span&gt;, W_constraint =maxnorm(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#限制权值的各个参数不能大于2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可用的约束限制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;maxnorm(m=2): 最大值约束&lt;/li&gt;
&lt;li&gt;nonneg(): 不允许负值&lt;/li&gt;
&lt;li&gt;unitnorm(): 归一化&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;实例：解决XOR问题&quot;&gt;&lt;a href=&quot;#实例：解决XOR问题&quot; class=&quot;headerlink&quot; title=&quot;实例：解决XOR问题&quot;&gt;&lt;/a&gt;实例：解决XOR问题&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.models &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Sequential&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.layers.core &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Activation, Dense&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; keras.optimizers &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; SGD&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X = np.zeros((&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), dtype=&lt;span class=&quot;string&quot;&gt;&#39;uint8&#39;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;#训练数据&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = np.zeros(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, dtype=&lt;span class=&quot;string&quot;&gt;&#39;uint8&#39;&lt;/span&gt;)&lt;span class=&quot;comment&quot;&gt;#训练标签&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = [&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;X[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model = Sequential()&lt;span class=&quot;comment&quot;&gt;#实例化模型&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Dense(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, input_dim=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;span class=&quot;comment&quot;&gt;#输入层，输入数据维数为2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Activation(&lt;span class=&quot;string&quot;&gt;&#39;sigmoid&#39;&lt;/span&gt;))&lt;span class=&quot;comment&quot;&gt;#设置激活函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Dense(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.add(Activation(&lt;span class=&quot;string&quot;&gt;&#39;sigmoid&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sgd = SGD(lr=&lt;span class=&quot;number&quot;&gt;0.1&lt;/span&gt;, decay=&lt;span class=&quot;number&quot;&gt;1e-6&lt;/span&gt;, momentum=&lt;span class=&quot;number&quot;&gt;0.9&lt;/span&gt;, nesterov=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;model.compile(loss=&lt;span class=&quot;string&quot;&gt;&#39;mean_squared_error&#39;&lt;/span&gt;, optimizer=sgd)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;history = model.fit(X, y, nb_epoch=&lt;span class=&quot;number&quot;&gt;10000&lt;/span&gt;, batch_size=&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;, show_accuracy=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;, verbose=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; model.predict(X)&lt;span class=&quot;comment&quot;&gt;#预测&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://keras.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keras Documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.lai18.com/user/301164.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keras 学习随笔&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/u012162613/article/details/45397033&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;深度学习框架Keras简介&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-4-7/16129390.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h1 id=&quot;Keras-简介&quot;&gt;&lt;a href=&quot;#Keras-简介&quot; class=&quot;headerlink&quot; title=&quot;Keras 简介&quot;&gt;&lt;/a&gt;Keras 简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://keras.io/&quot;&gt;Keras&lt;/a&gt;是一个用Python编写的基于 TensorFlow 和 Theano高度模块化的神经网络库。其最大的优点在于样例丰富，现有主流模型封装完美。复杂点的模型可以像搭积木一样搞出来，适合快速地搭建模型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Keras" scheme="http://yoursite.com/tags/Keras/"/>
    
      <category term="Deep Learning" scheme="http://yoursite.com/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Python连接MySQL</title>
    <link href="http://yoursite.com/2016/04/04/2016-04-04-Python%E8%BF%9E%E6%8E%A5MySQL.md/"/>
    <id>http://yoursite.com/2016/04/04/2016-04-04-Python连接MySQL.md/</id>
    <published>2016-04-04T03:00:00.000Z</published>
    <updated>2016-04-07T05:24:50.915Z</updated>
    
    <content type="html">&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-4-4/94530193.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h1 id=&quot;环境安装&quot;&gt;&lt;a href=&quot;#环境安装&quot; class=&quot;headerlink&quot; title=&quot;环境安装&quot;&gt;&lt;/a&gt;环境安装&lt;/h1&gt;&lt;p&gt;  安装MySQL：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install mysql-server
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;  安装MySQLdb模块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install python-mysqldb
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  测试是否安装成功：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import MySQLdb
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;MySQL建立数据库&quot;&gt;&lt;a href=&quot;#MySQL建立数据库&quot; class=&quot;headerlink&quot; title=&quot;MySQL建立数据库&quot;&gt;&lt;/a&gt;MySQL建立数据库&lt;/h1&gt;&lt;p&gt;  进入MySQL：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  进入MySQL并打开补全：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mysql -u USER -p --local-infile=1  --auto-rehash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  建立一个数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create database testdb character set utf8;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  调用已经建立的数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;use testdb;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  建立一个数据表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table users
(id int(2) not null primary key auto_increment,
username varchar(40),
password text,email text)
default charset=utf8;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  显示表格：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show tables;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  显示表格结构：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;desc users;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  表格中插入数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;insert into
users(username,password,email)
values(&amp;quot;qiwsir&amp;quot;,&amp;quot;123123&amp;quot;,&amp;quot;qiwsir@gmail.com&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  查询表格内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select * from users;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;Python操作数据库&quot;&gt;&lt;a href=&quot;#Python操作数据库&quot; class=&quot;headerlink&quot; title=&quot;Python操作数据库&quot;&gt;&lt;/a&gt;Python操作数据库&lt;/h1&gt;&lt;p&gt;  连接数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conn =
MySQLdb.connect
(host=&amp;quot;localhost&amp;quot;,user=&amp;quot;root&amp;quot;,
passwd=&amp;quot;123123&amp;quot;,db=&amp;quot;qiwsirtest&amp;quot;,charset=&amp;quot;utf8&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  用游标（指针）cursor的方式操作数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cur = conn.cursor()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  在表中插入一条记录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cur.execute(&amp;quot;insert into
users (username,password,email)
values (%s,%s,%s)&amp;quot;,(&amp;quot;python&amp;quot;,&amp;quot;123456&amp;quot;,&amp;quot;python@gmail.com&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  使插入的记录生效，提交：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conn.commit()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  同时插入多条记录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cur.executemany(&amp;quot;insert into
users (username,password,email)
values (%s,%s,%s)&amp;quot;,
((&amp;quot;google&amp;quot;,&amp;quot;111222&amp;quot;,&amp;quot;g@gmail.com&amp;quot;),
(&amp;quot;facebook&amp;quot;,&amp;quot;222333&amp;quot;,&amp;quot;f@face.book&amp;quot;),
(&amp;quot;github&amp;quot;,&amp;quot;333444&amp;quot;,&amp;quot;git@hub.com&amp;quot;),
(&amp;quot;docker&amp;quot;,&amp;quot;444555&amp;quot;,&amp;quot;doc@ker.com&amp;quot;)))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  要记得提交生效&lt;/p&gt;
&lt;p&gt;  查询数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cur.execute(&amp;quot;select * from users&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  上述操作只是得到结果的指针，想要显示查询结果，可以用到以下方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fetchall(self):接收全部的返回结果行.&lt;/li&gt;
&lt;li&gt;fwetchmany(size=None):接收size条返回结果行.如果size的值大于返回的结果行的数量,则会返回cursor.arraysize条数据.&lt;/li&gt;
&lt;li&gt;fetchone():返回一条结果行.&lt;/li&gt;
&lt;li&gt;scroll(value,mode=’relative’):移动指针到某一行.如果mode=’relative’,则表示从当前所在行移动value条,如果mode=’absolute’,则表示从结果集的第一行移动value条.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;  python的MySQLdb指针提供了一个参数，可以实现将读取到的数据变成字典形式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cur = conn.cursor(cursorclass=MySQLdb.cursors.DictCursor)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  更新数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cur.execute(&amp;quot;update users set username=%s where id=2&amp;quot;,(&amp;quot;mypython&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   如果再下述连接数据库的语句中，如果没有指定具体的数据库，则连接到MySQL：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conn = MySQLdb.connect
(host=&amp;quot;localhost&amp;quot;,
user=&amp;quot;root&amp;quot;,passwd=&amp;quot;123123&amp;quot;,
db=&amp;quot;qiwsirtest&amp;quot;,charset=&amp;quot;utf8&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  然后可以通过用conn.select_db()选择要操作的数据库：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conn.select_db(&amp;quot;testdb&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  不选数据库，而是要新建一个数据库，如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cur = conn.cursor()
cur.execute(&amp;quot;create database newtest&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  建立数据库之后，就可以选择这个数据库，然后在这个数据库中建立一个数据表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cur.execute(&amp;quot;create table newusers
(id int(2) primary key auto_increment,
username varchar(20), age int(2), email text)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  当进行完有关数据操作之后，最后要做的就是关闭游标（指针）和连接。用如下命令实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cur.close()
conn.close()
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;  &lt;a href=&quot;http://python.xiaoleilu.com/300/302.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;通过Python连接数据库&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-4-4/94530193.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h1 id=&quot;环境安装&quot;&gt;&lt;a href=&quot;#环境安装&quot; class=&quot;headerlink&quot; title=&quot;环境安装&quot;&gt;&lt;/a&gt;环境安装&lt;/h1&gt;&lt;p&gt;  安装MySQL：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install mysql-server
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>skimage hog函数解析</title>
    <link href="http://yoursite.com/2016/03/31/2016-03-31-Skimage%20hog%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2016/03/31/2016-03-31-Skimage hog函数用法解析/</id>
    <published>2016-03-31T03:00:00.000Z</published>
    <updated>2016-03-31T05:41:42.784Z</updated>
    
    <content type="html">&lt;h2 id=&quot;HOG简介&quot;&gt;&lt;a href=&quot;#HOG简介&quot; class=&quot;headerlink&quot; title=&quot;HOG简介&quot;&gt;&lt;/a&gt;HOG简介&lt;/h2&gt;&lt;p&gt;方向梯度直方图（英语：Histogram of oriented gradient，简称HOG）是应用在计算机视觉和图像处理领域，用于目标检测的特征描述器。这项技术是用来计算局部图像梯度的方向信息的统计值。这种方法跟边缘方向直方图（edge orientation histograms）、尺度不变特征变换（scale-invariant feature transform descriptors）以及形状上下文方法（ shape contexts）有很多相似之处，但与它们的不同点是：HOG描述器是在一个网格密集的大小统一的细胞单元（dense grid of uniformly spaced cells）上计算，而且为了提高性能，还采用了重叠的局部对比度归一化（overlapping local contrast normalization）技术。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-3-31/40452258.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;


&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;函数形式&quot;&gt;&lt;a href=&quot;#函数形式&quot; class=&quot;headerlink&quot; title=&quot;函数形式&quot;&gt;&lt;/a&gt;函数形式&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;skimage.feature.hog(image, orientations=&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;, pixels_per_cell=(&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;), cells_per_block=(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;), visualise=&lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt;, transform_sqrt=&lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt;, feature_vector=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;, normalise=&lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;hog函数实现的主要步骤&quot;&gt;&lt;a href=&quot;#hog函数实现的主要步骤&quot; class=&quot;headerlink&quot; title=&quot;hog函数实现的主要步骤&quot;&gt;&lt;/a&gt;hog函数实现的主要步骤&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;图像归一化（可选）&lt;/li&gt;
&lt;li&gt;计算x和y方向的梯度，包括大小和方向&lt;/li&gt;
&lt;li&gt;计算梯度柱状图&lt;/li&gt;
&lt;li&gt;对块状区域进行归一化处理&lt;/li&gt;
&lt;li&gt;得到一个一维的特征向量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体有关hog特征计算流程可参考：&lt;a href=&quot;http://buptldy.github.io/2016/03/31/2016-03-31-HOG%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Histograms of Oriented Gradients for Human Detection》论文笔记&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;hog函数参数解释&quot;&gt;&lt;a href=&quot;#hog函数参数解释&quot; class=&quot;headerlink&quot; title=&quot;hog函数参数解释&quot;&gt;&lt;/a&gt;hog函数参数解释&lt;/h2&gt;&lt;h3 id=&quot;传入参数&quot;&gt;&lt;a href=&quot;#传入参数&quot; class=&quot;headerlink&quot; title=&quot;传入参数&quot;&gt;&lt;/a&gt;传入参数&lt;/h3&gt;&lt;p&gt;image : (M, N) ndarray&lt;/p&gt;
&lt;p&gt;传入要进行hog特征计算的灰度图&lt;/p&gt;
&lt;p&gt;orientations : int&lt;/p&gt;
&lt;p&gt;设置方向梯度直方图的箱子个数&lt;/p&gt;
&lt;p&gt;pixels_per_cell : 2 tuple (int, int)&lt;/p&gt;
&lt;p&gt;设置每个单元的像素&lt;/p&gt;
&lt;p&gt;cells_per_block : 2 tuple (int,int)&lt;/p&gt;
&lt;p&gt;设置每个区块的单元数&lt;/p&gt;
&lt;p&gt;visualise : bool, optional&lt;/p&gt;
&lt;p&gt;设置是否返回可视化的hog特征&lt;/p&gt;
&lt;p&gt;transform_sqrt : bool, optional&lt;/p&gt;
&lt;p&gt;Apply power law compression to normalise the image before processing. DO NOT use this if the image contains negative values. Also see notes section below.&lt;br&gt;feature_vector : bool, optional&lt;/p&gt;
&lt;p&gt;Return the data as a feature vector by calling .ravel() on the result just before returning.&lt;br&gt;normalise : bool, deprecated&lt;/p&gt;
&lt;p&gt;The parameter is deprecated. Use transform_sqrt for power law compression. normalise has been deprecated.&lt;/p&gt;
&lt;h3 id=&quot;返回参数&quot;&gt;&lt;a href=&quot;#返回参数&quot; class=&quot;headerlink&quot; title=&quot;返回参数&quot;&gt;&lt;/a&gt;返回参数&lt;/h3&gt;&lt;p&gt;newarr : ndarray&lt;/p&gt;
&lt;p&gt;返回得到的一维hog特征&lt;/p&gt;
&lt;p&gt;hog_image : ndarray (if visualise=True)&lt;/p&gt;
&lt;p&gt;hog特征的可视化图像&lt;/p&gt;
&lt;h2 id=&quot;hog函数举例&quot;&gt;&lt;a href=&quot;#hog函数举例&quot; class=&quot;headerlink&quot; title=&quot;hog函数举例&quot;&gt;&lt;/a&gt;hog函数举例&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; skimage.feature &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; hog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; skimage &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; data, color, exposure&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;image = color.rgb2gray(data.astronaut())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fd, hog_image = hog(image, orientations=&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, pixels_per_cell=(&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    cells_per_block=(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), visualise=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fig, (ax1, ax2) = plt.subplots(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, figsize=(&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;), sharex=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;, sharey=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax1.axis(&lt;span class=&quot;string&quot;&gt;&#39;off&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax1.imshow(image, cmap=plt.cm.gray)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax1.set_title(&lt;span class=&quot;string&quot;&gt;&#39;Input image&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax1.set_adjustable(&lt;span class=&quot;string&quot;&gt;&#39;box-forced&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Rescale histogram for better display&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hog_image_rescaled = exposure.rescale_intensity(hog_image, in_range=(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0.02&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax2.axis(&lt;span class=&quot;string&quot;&gt;&#39;off&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax2.imshow(hog_image_rescaled, cmap=plt.cm.gray)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax2.set_title(&lt;span class=&quot;string&quot;&gt;&#39;Histogram of Oriented Gradients&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ax1.set_adjustable(&lt;span class=&quot;string&quot;&gt;&#39;box-forced&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-3-31/40452258.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HOG简介&quot;&gt;&lt;a href=&quot;#HOG简介&quot; class=&quot;headerlink&quot; title=&quot;HOG简介&quot;&gt;&lt;/a&gt;HOG简介&lt;/h2&gt;&lt;p&gt;方向梯度直方图（英语：Histogram of oriented gradient，简称HOG）是应用在计算机视觉和图像处理领域，用于目标检测的特征描述器。这项技术是用来计算局部图像梯度的方向信息的统计值。这种方法跟边缘方向直方图（edge orientation histograms）、尺度不变特征变换（scale-invariant feature transform descriptors）以及形状上下文方法（ shape contexts）有很多相似之处，但与它们的不同点是：HOG描述器是在一个网格密集的大小统一的细胞单元（dense grid of uniformly spaced cells）上计算，而且为了提高性能，还采用了重叠的局部对比度归一化（overlapping local contrast normalization）技术。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-3-31/40452258.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="HOG" scheme="http://yoursite.com/tags/HOG/"/>
    
      <category term="skimage" scheme="http://yoursite.com/tags/skimage/"/>
    
  </entry>
  
  <entry>
    <title>《Histograms of Oriented Gradients for Human Detection》论文笔记</title>
    <link href="http://yoursite.com/2016/03/31/2016-03-31-HOG%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/03/31/2016-03-31-HOG论文总结/</id>
    <published>2016-03-31T02:00:00.000Z</published>
    <updated>2016-03-31T02:17:05.158Z</updated>
    
    <content type="html">&lt;h1 id=&quot;HOG算法概述&quot;&gt;&lt;a href=&quot;#HOG算法概述&quot; class=&quot;headerlink&quot; title=&quot;HOG算法概述&quot;&gt;&lt;/a&gt;HOG算法概述&lt;/h1&gt;&lt;p&gt;局部目标的外表和形状可以被局部梯度或边缘方向的分布很好的描述,即使我们不知道对应的梯度和边缘的位置。在实际操作中,将图像分为小的细胞单元 (cells) ,每个细胞单元计算一个梯度方向 ( 或边缘方向 )直方图。为了对光照和阴影有更好的不变性,需要对直方图进行对比度归一化,可以通过将细胞单元组成更大的块 (blocks) 并归一化块内的所有细胞单元来实现。我们将归一化的块描述符叫做 HOG 描述子。将检测窗口中的所有块的 HOG 描述子组合起来就形成了最终的特征向量,然后使用 SVM 分类器进行人体检测,见下图。&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-3-31/19766259.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;HOG特征有个优点,它们提取的边缘和梯度特征能很好的抓住局部形状的特点,并且由于是       在局部进行提取,所以对几何和光学变化都有很好的不变性:变换或旋转对于足够小的区域影响很小。对于人体检测,在粗糙的空域采样 (coarse spatial sampling) 、精细的方向采样 (fine orientationsampling)和较强的局部光学归一化 (stronglocal photometric normalization) 这些条件下,只要行人大体上能够保持直立的姿势,就容许有一些细微的肢体动作,这些细微的动作可以被忽略而不影响检测效果。&lt;/p&gt;
&lt;h1 id=&quot;算法细节&quot;&gt;&lt;a href=&quot;#算法细节&quot; class=&quot;headerlink&quot; title=&quot;算法细节&quot;&gt;&lt;/a&gt;算法细节&lt;/h1&gt;&lt;h2 id=&quot;伽马颜色归一化&quot;&gt;&lt;a href=&quot;#伽马颜色归一化&quot; class=&quot;headerlink&quot; title=&quot;伽马颜色归一化&quot;&gt;&lt;/a&gt;伽马颜色归一化&lt;/h2&gt;&lt;p&gt;用不同的幂值 (gamma 参数 ) 评价了几种颜色空间,有灰度空间、 RGB 、 LAB ,结果表明,这些规范化对结果影响很小,可能是由于随后的描述子归一化能达到相似的效果。&lt;/p&gt;
&lt;h2 id=&quot;梯度计算&quot;&gt;&lt;a href=&quot;#梯度计算&quot; class=&quot;headerlink&quot; title=&quot;梯度计算&quot;&gt;&lt;/a&gt;梯度计算&lt;/h2&gt;&lt;p&gt;不同的梯度计算方法对检测器性能有很大影响,但事实证明最简单的梯度算子结果是最好的。采用了最简单的一维离散微分模板算子。测试表明，使用 Sobel 算子等其它算子或是引入高斯平滑反而会造成性能降低。对于带颜色的图像,分别计算每个颜色通道的梯度,以范数最大者作为该点的梯度向量。&lt;/p&gt;
&lt;h2 id=&quot;空间-方向-bin-统计&quot;&gt;&lt;a href=&quot;#空间-方向-bin-统计&quot; class=&quot;headerlink&quot; title=&quot;空间 / 方向 bin 统计&quot;&gt;&lt;/a&gt;空间 / 方向 bin 统计&lt;/h2&gt;&lt;p&gt;如下图的一个包含行人的图像，红色框标记一个 8 × 8 单元，这些 8 × 8 的单元将被用来计算 HOG 描述符。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-3-31/94180844.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;&lt;br&gt;在每个单元中，我们在每个像素上计算梯度矢量，将得到 64 个梯度矢量，梯度矢量相角在 0◦ → 180◦ 之间分布，我们对相角进行分箱 (bin)，每箱 20◦，一共 9 箱 (Dalal 和 Triggs 得到的最佳参数)。具有某一相角的梯度矢量的幅度按照权重分配给直方图。这涉及到权重投票表决机制， Dalal 和 Triggs 发现，采用梯度幅度进行分配表现最佳。例如，一个具有 85 度相角的梯度矢量将其幅度的 1/4 分配给中心为 70◦ 的箱，将剩余的 3/4 幅度分配给中心为 90◦ 的箱。这样就得到了下面的方向梯度直方图。&lt;br&gt;&lt;br&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-3-31/13507779.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;上面分配幅度的方法可以减少恰好位于两箱边界的梯度矢量的影响，否则，如果一个强梯度矢量恰好在边界上，其相角的一个很小的绕动都将对直方图造成非常大的影响。同时，在计算出梯度后进行高斯平滑，也可以缓解这种影响。另一方面，特征的复杂程度对分类器的影响很大。通过直方图的构造，我们将特征 64 个二元矢量量化为特征 9 个值，很好地压缩了特征的同时保留了单元的信息。设想对图像加上一些失真，方向梯度直方图的变化也不会很大，这是 HOG 特征的优点。&lt;/p&gt;
&lt;h2 id=&quot;归一化处理&quot;&gt;&lt;a href=&quot;#归一化处理&quot; class=&quot;headerlink&quot; title=&quot;归一化处理&quot;&gt;&lt;/a&gt;归一化处理&lt;/h2&gt;&lt;p&gt;前面提到，对图像所有像素进行加减后梯度矢量不变，接下来引入梯度矢量的标准化，使得其在像素值进行乘法运算后仍然保持不变。如果对单元内的像素值都乘以某一常数，梯度矢量的幅度明显会发生变化，幅度会增加常数因子,相角保持不变，这会造成整个直方图的每个箱的幅度增加常数因子。为了解决这个问题，需要引入梯度矢量标准化，一种简单的标准化方法是将梯度矢量除以其幅度，梯度矢量的幅度将保持 1，但是其相角不会发生变化。引入梯度矢量标准化以后，直方图各箱幅度在图像像素值整体乘以某个因子 (变化对比度) 时不会发生变化。除了对每个单元的直方图进行标准化外，另外一种方法是将固定数量的空域邻接的单元封装成区块，然后在区块上进行标准化。 Dalal 和 Triggs 使用 2 × 2 区块 (50% 重叠)，即 16 × 16 像素。将一个区块内的四个单元的直方图信息整合为 36 个值的特征 (9 × 4), 然后对这个 36 元矢量进行标准化。 Dalal 和 Triggs 考察了四种不同的区块标准化算法，设 v 为未标准化的区块梯度矢量， $||v||_{k}(k = 1, 2)$ 是 v 的 k-范数 (norm),e 是一个很小的常数 (具体值并不重要)，四种标准化算法如下：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-3-31/98414203.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;L2-Hys 是在 L2-norm 后进行截断，然后重新进行标准化。 Dalal 和 Triggs 发现 L2-Hys,L2-norm,L1-sqrt 性能相似，L1-norm 性能稍有下降，但都相对于未标准化的梯度矢量有明显的性能提升。区块重叠的影响是使得每个单元会在最终得到的 HOG 描述符中其作用的次数大于 1 次 (角单元出现 1 次，边单元出现 2 次，其它单元出现 4 次)，但每次出现都在不同的区块进行标准化。定义一个区块位移的步长为 8 像素，则可以实现 50% 的重叠。如果检测器窗口为 64x128像素，则会被分为 7 × 15 区块，每个区块包括 2 × 2 个单元，每个单元包括 8 × 8 像素，每个区块进行 9 箱直方图统计 (36 值)，最后的总特征矢量将有 7 × 15 × 4 × 9 = 3780 个特征值元素。&lt;/p&gt;
&lt;h2 id=&quot;SVM&quot;&gt;&lt;a href=&quot;#SVM&quot; class=&quot;headerlink&quot; title=&quot;SVM&quot;&gt;&lt;/a&gt;SVM&lt;/h2&gt;&lt;p&gt;分类器获取了 HOG 特征描述符之后，需要将其递交给监督学习分类器。 Dalal 和 Triggs 使用 SV M light 软件包配合HOG 描述符进行人体检测。 SVM 分类器寻找一个最佳超平面用作决策函数以实现二元分类，其特点是能够同时最小化经验误差与最大化几何边缘区。&lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://oncemore2020.github.io/blog/hog-using-opencv/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HOG/linSVM检测器&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/masibuaa/article/details/14056807&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;用于人体检测的方向梯度直方图&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HOG算法概述&quot;&gt;&lt;a href=&quot;#HOG算法概述&quot; class=&quot;headerlink&quot; title=&quot;HOG算法概述&quot;&gt;&lt;/a&gt;HOG算法概述&lt;/h1&gt;&lt;p&gt;局部目标的外表和形状可以被局部梯度或边缘方向的分布很好的描述,即使我们不知道对应的梯度和边缘的位置。在实际操作中,将图像分为小的细胞单元 (cells) ,每个细胞单元计算一个梯度方向 ( 或边缘方向 )直方图。为了对光照和阴影有更好的不变性,需要对直方图进行对比度归一化,可以通过将细胞单元组成更大的块 (blocks) 并归一化块内的所有细胞单元来实现。我们将归一化的块描述符叫做 HOG 描述子。将检测窗口中的所有块的 HOG 描述子组合起来就形成了最终的特征向量,然后使用 SVM 分类器进行人体检测,见下图。&lt;br&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-3-31/19766259.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Computer Vision" scheme="http://yoursite.com/tags/Computer-Vision/"/>
    
      <category term="HOG" scheme="http://yoursite.com/tags/HOG/"/>
    
  </entry>
  
  <entry>
    <title>pandas十分钟入门</title>
    <link href="http://yoursite.com/2016/03/25/2016-03-25-pandas%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2016/03/25/2016-03-25-pandas快速入门/</id>
    <published>2016-03-25T02:00:00.000Z</published>
    <updated>2016-03-26T07:04:02.591Z</updated>
    
    <content type="html">&lt;h1 id=&quot;10分钟简单介绍pandas&quot;&gt;&lt;a href=&quot;#10分钟简单介绍pandas&quot; class=&quot;headerlink&quot; title=&quot;10分钟简单介绍pandas&quot;&gt;&lt;/a&gt;10分钟简单介绍pandas&lt;/h1&gt;&lt;p&gt;首先，导入模块如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;pandas数据结构：Series&quot;&gt;&lt;a href=&quot;#pandas数据结构：Series&quot; class=&quot;headerlink&quot; title=&quot;pandas数据结构：Series&quot;&gt;&lt;/a&gt;pandas数据结构：Series&lt;/h1&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Series可以简单地被认为是一维的数组。 Series 和一维数组最主要的区别在于 Series类型具有索引( index ),可以和另一个编程中常见的数据结构哈希( Hash )联系起来。&lt;/p&gt;
&lt;p&gt;创建Series类型数据结构，如果没有传入索引，pandas默认的索引为从0开始的整数。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;s = pd.Series([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,np.nan,&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;s&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;0     1
1     3
2     5
3   NaN
4     6
5     8
dtype: float64
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;pandas数据结构：DataFrame&quot;&gt;&lt;a href=&quot;#pandas数据结构：DataFrame&quot; class=&quot;headerlink&quot; title=&quot;pandas数据结构：DataFrame&quot;&gt;&lt;/a&gt;pandas数据结构：DataFrame&lt;/h1&gt;&lt;p&gt;DataFrame 是将数个 Series 按列合并而成的二维数据结构,每一列单独取出来是一个 Series ,这和 SQL 数据库中取出的数据是很类似的。所以,按&lt;br&gt;列对一个 DataFrame 进行处理更为方便,用户在编程时注意培养按列构建数据的思维。 DataFrame 的优势在于可以方便地处理不同类型的列,因此,就不要考虑如何对一个全是浮点数的 DataFrame 求逆之类的问题了,处理这种问题还是把数据存成 NumPy 的 matrix 类型比较便利一些。&lt;/p&gt;
&lt;p&gt;通过传入 numpy array数据创建 DataFrame：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dates = pd.date_range(&lt;span class=&quot;string&quot;&gt;&#39;20130101&#39;&lt;/span&gt;, periods=&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dates&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;DatetimeIndex([&amp;apos;2013-01-01&amp;apos;, &amp;apos;2013-01-02&amp;apos;, &amp;apos;2013-01-03&amp;apos;, &amp;apos;2013-01-04&amp;apos;,
               &amp;apos;2013-01-05&amp;apos;, &amp;apos;2013-01-06&amp;apos;],
              dtype=&amp;apos;datetime64[ns]&amp;apos;, freq=&amp;apos;D&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df = pd.DataFrame(np.random.randn(&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;), index=dates, columns=list(&lt;span class=&quot;string&quot;&gt;&#39;ABCD&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-01&lt;/th&gt;       &lt;td&gt;0.212880&lt;/td&gt;       &lt;td&gt;0.351725&lt;/td&gt;       &lt;td&gt;-1.350579&lt;/td&gt;       &lt;td&gt;-0.107403&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-02&lt;/th&gt;       &lt;td&gt;-0.857903&lt;/td&gt;       &lt;td&gt;-1.783324&lt;/td&gt;       &lt;td&gt;1.162888&lt;/td&gt;       &lt;td&gt;-0.488226&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-03&lt;/th&gt;       &lt;td&gt;-0.245746&lt;/td&gt;       &lt;td&gt;-0.226585&lt;/td&gt;       &lt;td&gt;1.749624&lt;/td&gt;       &lt;td&gt;1.140817&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-04&lt;/th&gt;       &lt;td&gt;0.032400&lt;/td&gt;       &lt;td&gt;-0.264382&lt;/td&gt;       &lt;td&gt;0.125095&lt;/td&gt;       &lt;td&gt;-1.322739&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-05&lt;/th&gt;       &lt;td&gt;-2.260707&lt;/td&gt;       &lt;td&gt;0.064878&lt;/td&gt;       &lt;td&gt;0.231025&lt;/td&gt;       &lt;td&gt;0.682991&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-06&lt;/th&gt;       &lt;td&gt;0.603739&lt;/td&gt;       &lt;td&gt;1.490709&lt;/td&gt;       &lt;td&gt;0.249649&lt;/td&gt;       &lt;td&gt;1.822501&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;  

&lt;p&gt;传入字典对象创建DataFrame：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df2 = pd.DataFrame(&amp;#123; &lt;span class=&quot;string&quot;&gt;&#39;A&#39;&lt;/span&gt; : &lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....:                &lt;span class=&quot;string&quot;&gt;&#39;B&#39;&lt;/span&gt; : pd.Timestamp(&lt;span class=&quot;string&quot;&gt;&#39;20130102&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....:                &lt;span class=&quot;string&quot;&gt;&#39;C&#39;&lt;/span&gt; : pd.Series(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,index=list(range(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)),dtype=&lt;span class=&quot;string&quot;&gt;&#39;float32&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....:                &lt;span class=&quot;string&quot;&gt;&#39;D&#39;&lt;/span&gt; : np.array([&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] * &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,dtype=&lt;span class=&quot;string&quot;&gt;&#39;int32&#39;&lt;/span&gt;),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....:                &lt;span class=&quot;string&quot;&gt;&#39;E&#39;&lt;/span&gt; : pd.Categorical([&lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;train&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;test&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;train&quot;&lt;/span&gt;]),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;....:                &lt;span class=&quot;string&quot;&gt;&#39;F&#39;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&#39;foo&#39;&lt;/span&gt; &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;       &lt;th&gt;E&lt;/th&gt;       &lt;th&gt;F&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;0&lt;/th&gt;       &lt;td&gt;1&lt;/td&gt;       &lt;td&gt;2013-01-02&lt;/td&gt;       &lt;td&gt;1&lt;/td&gt;       &lt;td&gt;3&lt;/td&gt;       &lt;td&gt;test&lt;/td&gt;       &lt;td&gt;foo&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;1&lt;/th&gt;       &lt;td&gt;1&lt;/td&gt;       &lt;td&gt;2013-01-02&lt;/td&gt;       &lt;td&gt;1&lt;/td&gt;       &lt;td&gt;3&lt;/td&gt;       &lt;td&gt;train&lt;/td&gt;       &lt;td&gt;foo&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2&lt;/th&gt;       &lt;td&gt;1&lt;/td&gt;       &lt;td&gt;2013-01-02&lt;/td&gt;       &lt;td&gt;1&lt;/td&gt;       &lt;td&gt;3&lt;/td&gt;       &lt;td&gt;test&lt;/td&gt;       &lt;td&gt;foo&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;3&lt;/th&gt;       &lt;td&gt;1&lt;/td&gt;       &lt;td&gt;2013-01-02&lt;/td&gt;       &lt;td&gt;1&lt;/td&gt;       &lt;td&gt;3&lt;/td&gt;       &lt;td&gt;train&lt;/td&gt;       &lt;td&gt;foo&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;    

&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df2.F&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;0    foo
1    foo
2    foo
3    foo
Name: F, dtype: object
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df2.A&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;0    1
1    1
2    1
3    1
Name: A, dtype: float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看数据顶部或底部的几行：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df.head(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-01&lt;/th&gt;       &lt;td&gt;0.212880&lt;/td&gt;       &lt;td&gt;0.351725&lt;/td&gt;       &lt;td&gt;-1.350579&lt;/td&gt;       &lt;td&gt;-0.107403&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-02&lt;/th&gt;       &lt;td&gt;-0.857903&lt;/td&gt;       &lt;td&gt;-1.783324&lt;/td&gt;       &lt;td&gt;1.162888&lt;/td&gt;       &lt;td&gt;-0.488226&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;  



&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df.tail(&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-04&lt;/th&gt;       &lt;td&gt;0.032400&lt;/td&gt;       &lt;td&gt;-0.264382&lt;/td&gt;       &lt;td&gt;0.125095&lt;/td&gt;       &lt;td&gt;-1.322739&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-05&lt;/th&gt;       &lt;td&gt;-2.260707&lt;/td&gt;       &lt;td&gt;0.064878&lt;/td&gt;       &lt;td&gt;0.231025&lt;/td&gt;       &lt;td&gt;0.682991&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-06&lt;/th&gt;       &lt;td&gt;0.603739&lt;/td&gt;       &lt;td&gt;1.490709&lt;/td&gt;       &lt;td&gt;0.249649&lt;/td&gt;       &lt;td&gt;1.822501&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;   

&lt;p&gt;显示行列索引和里面的值;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df.index&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;DatetimeIndex([&amp;apos;2013-01-01&amp;apos;, &amp;apos;2013-01-02&amp;apos;, &amp;apos;2013-01-03&amp;apos;, &amp;apos;2013-01-04&amp;apos;,
               &amp;apos;2013-01-05&amp;apos;, &amp;apos;2013-01-06&amp;apos;],
              dtype=&amp;apos;datetime64[ns]&amp;apos;, freq=&amp;apos;D&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df.columns&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;Index([u&amp;apos;A&amp;apos;, u&amp;apos;B&amp;apos;, u&amp;apos;C&amp;apos;, u&amp;apos;D&amp;apos;], dtype=&amp;apos;object&amp;apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df.values&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;array([[ 0.21287973,  0.35172526, -1.35057903, -0.10740265],
       [-0.85790301, -1.78332415,  1.16288782, -0.48822551],
       [-0.24574644, -0.22658458,  1.74962416,  1.14081656],
       [ 0.03240016, -0.26438175,  0.12509531, -1.32273918],
       [-2.26070679,  0.06487812,  0.23102475,  0.68299111],
       [ 0.60373902,  1.4907093 ,  0.24964875,  1.82250141]])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显示数据的简单统计：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df.describe()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;count&lt;/th&gt;       &lt;td&gt;6.000000&lt;/td&gt;       &lt;td&gt;6.000000&lt;/td&gt;       &lt;td&gt;6.000000&lt;/td&gt;       &lt;td&gt;6.000000&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;mean&lt;/th&gt;       &lt;td&gt;-0.419223&lt;/td&gt;       &lt;td&gt;-0.061163&lt;/td&gt;       &lt;td&gt;0.361284&lt;/td&gt;       &lt;td&gt;0.287990&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;std&lt;/th&gt;       &lt;td&gt;1.026018&lt;/td&gt;       &lt;td&gt;1.061053&lt;/td&gt;       &lt;td&gt;1.056953&lt;/td&gt;       &lt;td&gt;1.148160&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;min&lt;/th&gt;       &lt;td&gt;-2.260707&lt;/td&gt;       &lt;td&gt;-1.783324&lt;/td&gt;       &lt;td&gt;-1.350579&lt;/td&gt;       &lt;td&gt;-1.322739&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;25%&lt;/th&gt;       &lt;td&gt;-0.704864&lt;/td&gt;       &lt;td&gt;-0.254932&lt;/td&gt;       &lt;td&gt;0.151578&lt;/td&gt;       &lt;td&gt;-0.393020&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;50%&lt;/th&gt;       &lt;td&gt;-0.106673&lt;/td&gt;       &lt;td&gt;-0.080853&lt;/td&gt;       &lt;td&gt;0.240337&lt;/td&gt;       &lt;td&gt;0.287794&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;75%&lt;/th&gt;       &lt;td&gt;0.167760&lt;/td&gt;       &lt;td&gt;0.280013&lt;/td&gt;       &lt;td&gt;0.934578&lt;/td&gt;       &lt;td&gt;1.026360&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;max&lt;/th&gt;       &lt;td&gt;0.603739&lt;/td&gt;       &lt;td&gt;1.490709&lt;/td&gt;       &lt;td&gt;1.749624&lt;/td&gt;       &lt;td&gt;1.822501&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;   

&lt;p&gt;数据转置：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df.T&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;2013-01-01 00:00:00&lt;/th&gt;       &lt;th&gt;2013-01-02 00:00:00&lt;/th&gt;       &lt;th&gt;2013-01-03 00:00:00&lt;/th&gt;       &lt;th&gt;2013-01-04 00:00:00&lt;/th&gt;       &lt;th&gt;2013-01-05 00:00:00&lt;/th&gt;       &lt;th&gt;2013-01-06 00:00:00&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;td&gt;0.212880&lt;/td&gt;       &lt;td&gt;-0.857903&lt;/td&gt;       &lt;td&gt;-0.245746&lt;/td&gt;       &lt;td&gt;0.032400&lt;/td&gt;       &lt;td&gt;-2.260707&lt;/td&gt;       &lt;td&gt;0.603739&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;td&gt;0.351725&lt;/td&gt;       &lt;td&gt;-1.783324&lt;/td&gt;       &lt;td&gt;-0.226585&lt;/td&gt;       &lt;td&gt;-0.264382&lt;/td&gt;       &lt;td&gt;0.064878&lt;/td&gt;       &lt;td&gt;1.490709&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;td&gt;-1.350579&lt;/td&gt;       &lt;td&gt;1.162888&lt;/td&gt;       &lt;td&gt;1.749624&lt;/td&gt;       &lt;td&gt;0.125095&lt;/td&gt;       &lt;td&gt;0.231025&lt;/td&gt;       &lt;td&gt;0.249649&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;D&lt;/th&gt;       &lt;td&gt;-0.107403&lt;/td&gt;       &lt;td&gt;-0.488226&lt;/td&gt;       &lt;td&gt;1.140817&lt;/td&gt;       &lt;td&gt;-1.322739&lt;/td&gt;       &lt;td&gt;0.682991&lt;/td&gt;       &lt;td&gt;1.822501&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;



&lt;p&gt;按某个索引排序：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df.sort_index(axis=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,ascending=&lt;span class=&quot;keyword&quot;&gt;False&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-01&lt;/th&gt;       &lt;td&gt;-0.107403&lt;/td&gt;       &lt;td&gt;-1.350579&lt;/td&gt;       &lt;td&gt;0.351725&lt;/td&gt;       &lt;td&gt;0.212880&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-02&lt;/th&gt;       &lt;td&gt;-0.488226&lt;/td&gt;       &lt;td&gt;1.162888&lt;/td&gt;       &lt;td&gt;-1.783324&lt;/td&gt;       &lt;td&gt;-0.857903&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-03&lt;/th&gt;       &lt;td&gt;1.140817&lt;/td&gt;       &lt;td&gt;1.749624&lt;/td&gt;       &lt;td&gt;-0.226585&lt;/td&gt;       &lt;td&gt;-0.245746&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-04&lt;/th&gt;       &lt;td&gt;-1.322739&lt;/td&gt;       &lt;td&gt;0.125095&lt;/td&gt;       &lt;td&gt;-0.264382&lt;/td&gt;       &lt;td&gt;0.032400&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-05&lt;/th&gt;       &lt;td&gt;0.682991&lt;/td&gt;       &lt;td&gt;0.231025&lt;/td&gt;       &lt;td&gt;0.064878&lt;/td&gt;       &lt;td&gt;-2.260707&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-06&lt;/th&gt;       &lt;td&gt;1.822501&lt;/td&gt;       &lt;td&gt;0.249649&lt;/td&gt;       &lt;td&gt;1.490709&lt;/td&gt;       &lt;td&gt;0.603739&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;  


&lt;p&gt;按数据的值排序：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df.sort_values(by=&lt;span class=&quot;string&quot;&gt;&#39;B&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-02&lt;/th&gt;       &lt;td&gt;-0.857903&lt;/td&gt;       &lt;td&gt;-1.783324&lt;/td&gt;       &lt;td&gt;1.162888&lt;/td&gt;       &lt;td&gt;-0.488226&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-04&lt;/th&gt;       &lt;td&gt;0.032400&lt;/td&gt;       &lt;td&gt;-0.264382&lt;/td&gt;       &lt;td&gt;0.125095&lt;/td&gt;       &lt;td&gt;-1.322739&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-03&lt;/th&gt;       &lt;td&gt;-0.245746&lt;/td&gt;       &lt;td&gt;-0.226585&lt;/td&gt;       &lt;td&gt;1.749624&lt;/td&gt;       &lt;td&gt;1.140817&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-05&lt;/th&gt;       &lt;td&gt;-2.260707&lt;/td&gt;       &lt;td&gt;0.064878&lt;/td&gt;       &lt;td&gt;0.231025&lt;/td&gt;       &lt;td&gt;0.682991&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-01&lt;/th&gt;       &lt;td&gt;0.212880&lt;/td&gt;       &lt;td&gt;0.351725&lt;/td&gt;       &lt;td&gt;-1.350579&lt;/td&gt;       &lt;td&gt;-0.107403&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-06&lt;/th&gt;       &lt;td&gt;0.603739&lt;/td&gt;       &lt;td&gt;1.490709&lt;/td&gt;       &lt;td&gt;0.249649&lt;/td&gt;       &lt;td&gt;1.822501&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;



&lt;p&gt;选出某一类：(同df.A)&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df[&lt;span class=&quot;string&quot;&gt;&#39;A&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;2013-01-01    0.212880
2013-01-02   -0.857903
2013-01-03   -0.245746
2013-01-04    0.032400
2013-01-05   -2.260707
2013-01-06    0.603739
Freq: D, Name: A, dtype: float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过[]切分出几行：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-01&lt;/th&gt;       &lt;td&gt;0.212880&lt;/td&gt;       &lt;td&gt;0.351725&lt;/td&gt;       &lt;td&gt;-1.350579&lt;/td&gt;       &lt;td&gt;-0.107403&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-02&lt;/th&gt;       &lt;td&gt;-0.857903&lt;/td&gt;       &lt;td&gt;-1.783324&lt;/td&gt;       &lt;td&gt;1.162888&lt;/td&gt;       &lt;td&gt;-0.488226&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-03&lt;/th&gt;       &lt;td&gt;-0.245746&lt;/td&gt;       &lt;td&gt;-0.226585&lt;/td&gt;       &lt;td&gt;1.749624&lt;/td&gt;       &lt;td&gt;1.140817&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;




&lt;pre&gt;&lt;code&gt;df[&amp;apos;20130102&amp;apos;:&amp;apos;20130104&amp;apos;]
&lt;/code&gt;&lt;/pre&gt;&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-02&lt;/th&gt;       &lt;td&gt;-0.857903&lt;/td&gt;       &lt;td&gt;-1.783324&lt;/td&gt;       &lt;td&gt;1.162888&lt;/td&gt;       &lt;td&gt;-0.488226&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-03&lt;/th&gt;       &lt;td&gt;-0.245746&lt;/td&gt;       &lt;td&gt;-0.226585&lt;/td&gt;       &lt;td&gt;1.749624&lt;/td&gt;       &lt;td&gt;1.140817&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-04&lt;/th&gt;       &lt;td&gt;0.032400&lt;/td&gt;       &lt;td&gt;-0.264382&lt;/td&gt;       &lt;td&gt;0.125095&lt;/td&gt;       &lt;td&gt;-1.322739&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;




&lt;p&gt;通过标签选择：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df.loc[dates[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;],[&lt;span class=&quot;string&quot;&gt;&#39;A&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;B&#39;&lt;/span&gt;]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;A    &lt;span class=&quot;number&quot;&gt;0.212880&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B    &lt;span class=&quot;number&quot;&gt;0.351725&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Name: &lt;span class=&quot;number&quot;&gt;2013&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-01&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;-01&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;00&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;00&lt;/span&gt;, dtype: float64&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过位置选取：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df.iloc[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-02&lt;/th&gt;       &lt;td&gt;-0.857903&lt;/td&gt;       &lt;td&gt;-1.783324&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-03&lt;/th&gt;       &lt;td&gt;-0.245746&lt;/td&gt;       &lt;td&gt;-0.226585&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;  


&lt;p&gt;reindex方法，能够增加行和列：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df1 = df.reindex(index=dates[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;], columns=list(df.columns) + [&lt;span class=&quot;string&quot;&gt;&#39;E&#39;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df1.loc[dates[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]:dates[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;],&lt;span class=&quot;string&quot;&gt;&#39;E&#39;&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;df1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;       &lt;th&gt;E&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-01&lt;/th&gt;       &lt;td&gt;0.212880&lt;/td&gt;       &lt;td&gt;0.351725&lt;/td&gt;       &lt;td&gt;-1.350579&lt;/td&gt;       &lt;td&gt;-0.107403&lt;/td&gt;       &lt;td&gt;1&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-02&lt;/th&gt;       &lt;td&gt;-0.857903&lt;/td&gt;       &lt;td&gt;-1.783324&lt;/td&gt;       &lt;td&gt;1.162888&lt;/td&gt;       &lt;td&gt;-0.488226&lt;/td&gt;       &lt;td&gt;1&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-03&lt;/th&gt;       &lt;td&gt;-0.245746&lt;/td&gt;       &lt;td&gt;-0.226585&lt;/td&gt;       &lt;td&gt;1.749624&lt;/td&gt;       &lt;td&gt;1.140817&lt;/td&gt;       &lt;td&gt;NaN&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-04&lt;/th&gt;       &lt;td&gt;0.032400&lt;/td&gt;       &lt;td&gt;-0.264382&lt;/td&gt;       &lt;td&gt;0.125095&lt;/td&gt;       &lt;td&gt;-1.322739&lt;/td&gt;       &lt;td&gt;NaN&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;



&lt;p&gt;丢失数据的处理:&lt;/p&gt;
&lt;p&gt;去掉有丢失数据的所有行：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df1.dropna(how=&lt;span class=&quot;string&quot;&gt;&#39;any&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;       &lt;th&gt;E&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-01&lt;/th&gt;       &lt;td&gt;0.212880&lt;/td&gt;       &lt;td&gt;0.351725&lt;/td&gt;       &lt;td&gt;-1.350579&lt;/td&gt;       &lt;td&gt;-0.107403&lt;/td&gt;       &lt;td&gt;1&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-02&lt;/th&gt;       &lt;td&gt;-0.857903&lt;/td&gt;       &lt;td&gt;-1.783324&lt;/td&gt;       &lt;td&gt;1.162888&lt;/td&gt;       &lt;td&gt;-0.488226&lt;/td&gt;       &lt;td&gt;1&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;  


&lt;p&gt;填充丢失数据&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df1.fillna(value=&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;       &lt;th&gt;E&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-01&lt;/th&gt;       &lt;td&gt;0.212880&lt;/td&gt;       &lt;td&gt;0.351725&lt;/td&gt;       &lt;td&gt;-1.350579&lt;/td&gt;       &lt;td&gt;-0.107403&lt;/td&gt;       &lt;td&gt;1&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-02&lt;/th&gt;       &lt;td&gt;-0.857903&lt;/td&gt;       &lt;td&gt;-1.783324&lt;/td&gt;       &lt;td&gt;1.162888&lt;/td&gt;       &lt;td&gt;-0.488226&lt;/td&gt;       &lt;td&gt;1&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-03&lt;/th&gt;       &lt;td&gt;-0.245746&lt;/td&gt;       &lt;td&gt;-0.226585&lt;/td&gt;       &lt;td&gt;1.749624&lt;/td&gt;       &lt;td&gt;1.140817&lt;/td&gt;       &lt;td&gt;5&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-04&lt;/th&gt;       &lt;td&gt;0.032400&lt;/td&gt;       &lt;td&gt;-0.264382&lt;/td&gt;       &lt;td&gt;0.125095&lt;/td&gt;       &lt;td&gt;-1.322739&lt;/td&gt;       &lt;td&gt;5&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;  


&lt;p&gt;判断是否有丢失数据：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pd.isnull(df1)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;       &lt;th&gt;E&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-01&lt;/th&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-02&lt;/th&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-03&lt;/th&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;True&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2013-01-04&lt;/th&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;False&lt;/td&gt;       &lt;td&gt;True&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;

&lt;h1 id=&quot;读取文件&quot;&gt;&lt;a href=&quot;#读取文件&quot; class=&quot;headerlink&quot; title=&quot;读取文件&quot;&gt;&lt;/a&gt;读取文件&lt;/h1&gt;&lt;p&gt;写csv文件：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;df.to_csv(&lt;span class=&quot;string&quot;&gt;&#39;foo.csv&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;读csv文件：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;pd.read_csv(&lt;span class=&quot;string&quot;&gt;&#39;foo.csv&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;   &lt;thead&gt;     &lt;tr style=&quot;text-align: right;&quot;&gt;       &lt;th&gt;&lt;/th&gt;       &lt;th&gt;Unnamed: 0&lt;/th&gt;       &lt;th&gt;A&lt;/th&gt;       &lt;th&gt;B&lt;/th&gt;       &lt;th&gt;C&lt;/th&gt;       &lt;th&gt;D&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;th&gt;0&lt;/th&gt;       &lt;td&gt;2013-01-01&lt;/td&gt;       &lt;td&gt;0.212880&lt;/td&gt;       &lt;td&gt;0.351725&lt;/td&gt;       &lt;td&gt;-1.350579&lt;/td&gt;       &lt;td&gt;-0.107403&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;1&lt;/th&gt;       &lt;td&gt;2013-01-02&lt;/td&gt;       &lt;td&gt;-0.857903&lt;/td&gt;       &lt;td&gt;-1.783324&lt;/td&gt;       &lt;td&gt;1.162888&lt;/td&gt;       &lt;td&gt;-0.488226&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;2&lt;/th&gt;       &lt;td&gt;2013-01-03&lt;/td&gt;       &lt;td&gt;-0.245746&lt;/td&gt;       &lt;td&gt;-0.226585&lt;/td&gt;       &lt;td&gt;1.749624&lt;/td&gt;       &lt;td&gt;1.140817&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;3&lt;/th&gt;       &lt;td&gt;2013-01-04&lt;/td&gt;       &lt;td&gt;0.032400&lt;/td&gt;       &lt;td&gt;-0.264382&lt;/td&gt;       &lt;td&gt;0.125095&lt;/td&gt;       &lt;td&gt;-1.322739&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;4&lt;/th&gt;       &lt;td&gt;2013-01-05&lt;/td&gt;       &lt;td&gt;-2.260707&lt;/td&gt;       &lt;td&gt;0.064878&lt;/td&gt;       &lt;td&gt;0.231025&lt;/td&gt;       &lt;td&gt;0.682991&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;th&gt;5&lt;/th&gt;       &lt;td&gt;2013-01-06&lt;/td&gt;       &lt;td&gt;0.603739&lt;/td&gt;       &lt;td&gt;1.490709&lt;/td&gt;       &lt;td&gt;0.249649&lt;/td&gt;       &lt;td&gt;1.822501&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;  



&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/10min.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;10 Minutes to pandas¶
&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;10分钟简单介绍pandas&quot;&gt;&lt;a href=&quot;#10分钟简单介绍pandas&quot; class=&quot;headerlink&quot; title=&quot;10分钟简单介绍pandas&quot;&gt;&lt;/a&gt;10分钟简单介绍pandas&lt;/h1&gt;&lt;p&gt;首先，导入模块如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;pandas数据结构：Series&quot;&gt;&lt;a href=&quot;#pandas数据结构：Series&quot; class=&quot;headerlink&quot; title=&quot;pandas数据结构：Series&quot;&gt;&lt;/a&gt;pandas数据结构：Series&lt;/h1&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="pandas" scheme="http://yoursite.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>Git命令总结</title>
    <link href="http://yoursite.com/2016/03/02/2016-03-02-GIT%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/03/02/2016-03-02-GIT命令总结/</id>
    <published>2016-03-02T02:00:00.000Z</published>
    <updated>2016-03-14T05:34:41.203Z</updated>
    
    <content type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建版本库&lt;/p&gt;
&lt;p&gt; 初始化一个Git仓库，使用git init命令。&lt;/p&gt;
&lt;p&gt; 添加文件到Git仓库，分两步：&lt;/p&gt;
&lt;p&gt; 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；&lt;/file&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt; 第二步，使用命令git commit，完成。&lt;/p&gt;
&lt;p&gt; 要随时掌握工作区的状态，使用git status命令。&lt;/p&gt;
&lt;p&gt; 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;版本回退&lt;/p&gt;
&lt;p&gt; HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。&lt;/p&gt;
&lt;p&gt; 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。&lt;/p&gt;
&lt;p&gt; 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工作区和暂存区&lt;/p&gt;
&lt;p&gt; 工作区（Working Directory）：就是你在电脑里能看到的目录。&lt;/p&gt;
&lt;p&gt; 版本库（Repository）：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。&lt;/p&gt;
&lt;p&gt; Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-3-10/74272820.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt; 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：&lt;/p&gt;
&lt;p&gt; 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；&lt;/p&gt;
&lt;p&gt; 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。&lt;/p&gt;
&lt;p&gt; 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。&lt;/p&gt;
&lt;p&gt; 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。&lt;/p&gt;
&lt;p&gt; Git是如何跟踪修改的:每次修改，如果不add到暂存区，那就不会加入到commit中。&lt;/p&gt;
&lt;p&gt; 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。&lt;/p&gt;
&lt;p&gt; 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。&lt;/p&gt;
&lt;p&gt; 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;远程仓库&lt;/p&gt;
&lt;p&gt; 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；&lt;/p&gt;
&lt;p&gt; 关联后，使用命令git push -u origin master第一次推送master分支的所有内容；&lt;/p&gt;
&lt;p&gt; 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建和合并分支&lt;/p&gt;
&lt;p&gt; 查看分支：git branch&lt;/p&gt;
&lt;p&gt; 创建分支：git branch &lt;name&gt;&lt;/name&gt;&lt;/p&gt;
&lt;p&gt; 切换分支：git checkout &lt;name&gt;&lt;/name&gt;&lt;/p&gt;
&lt;p&gt; 创建+切换分支：git checkout -b &lt;name&gt;&lt;/name&gt;&lt;/p&gt;
&lt;p&gt; 合并某分支到当前分支：git merge &lt;name&gt;&lt;/name&gt;&lt;/p&gt;
&lt;p&gt; 删除分支：git branch -d &lt;name&gt;&lt;/name&gt;&lt;/p&gt;
&lt;p&gt; 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。&lt;/p&gt;
&lt;p&gt; 用git log –graph命令可以看到分支合并图。&lt;/p&gt;
&lt;p&gt; 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；&lt;/p&gt;
&lt;p&gt; 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。&lt;/p&gt;
&lt;p&gt; 开发一个新feature，最好新建一个分支；&lt;/p&gt;
&lt;p&gt; 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。&lt;/name&gt;&lt;/p&gt;
&lt;p&gt; 查看远程库信息，使用git remote -v；&lt;/p&gt;
&lt;p&gt; 本地新建的分支如果不推送到远程，对其他人就是不可见的；&lt;/p&gt;
&lt;p&gt; 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；&lt;/p&gt;
&lt;p&gt; 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；&lt;/p&gt;
&lt;p&gt; 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；&lt;/p&gt;
&lt;p&gt; 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。&lt;/p&gt;
&lt;p&gt; 命令git tag &lt;name&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id；&lt;/name&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标签管理&lt;/p&gt;
&lt;p&gt; git tag -a &lt;tagname&gt; -m “blablabla…”可以指定标签信息；&lt;/tagname&gt;&lt;/p&gt;
&lt;p&gt; git tag -s &lt;tagname&gt; -m “blablabla…”可以用PGP签名标签；&lt;/tagname&gt;&lt;/p&gt;
&lt;p&gt; 命令git tag可以查看所有标签。&lt;/p&gt;
&lt;p&gt; 命令git push origin &lt;tagname&gt;可以推送一个本地标签；&lt;/tagname&gt;&lt;/p&gt;
&lt;p&gt; 命令git push origin –tags可以推送全部未推送过的本地标签；&lt;/p&gt;
&lt;p&gt; 命令git tag -d &lt;tagname&gt;可以删除一个本地标签；&lt;/tagname&gt;&lt;/p&gt;
&lt;p&gt; 命令git push origin :refs/tags/&lt;tagname&gt;可以删除一个远程标签&lt;/tagname&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Github使用&lt;/p&gt;
&lt;p&gt; 在GitHub上，可以任意Fork开源仓库；&lt;/p&gt;
&lt;p&gt; 自己拥有Fork后的仓库的读写权限；&lt;/p&gt;
&lt;p&gt; 可以推送pull request给官方仓库来贡献代码。&lt;/p&gt;
&lt;p&gt; 忽略某些文件时，需要编写.gitignore；&lt;/p&gt;
&lt;p&gt; .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xritj.com1.z0.glb.clouddn.com/16-3-10/93928228.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Git教程-廖雪峰的官方网站&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建版本库&lt;/p&gt;
&lt;p&gt; 初始化一个Git仓库，使用git init命令。&lt;/p&gt;
&lt;p&gt; 添加文件到Git仓库，分两步：&lt;/p&gt;
&lt;p&gt; 第一步，使用命令git add &lt;file&gt;，注意，可反复多次使用，添加多个文件；&lt;/p&gt;
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>近似算法[Approximation algorithm]</title>
    <link href="http://yoursite.com/2016/01/12/2016-01-12-%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2016/01/12/2016-01-12-近似算法/</id>
    <published>2016-01-12T02:00:00.000Z</published>
    <updated>2016-03-16T06:58:36.391Z</updated>
    
    <content type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;许多具有卖际意义的问题都是 &lt;a href=&quot;http://buptldy.github.io/2016/01/11/NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E8%AF%81%E6%98%8E/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NP 完全&lt;/a&gt;问题。我们不知道如何在多项式时间内求得最优解。但是，这些问题通常又十分重要， 我们不能因此而放弃对它们的求解。即使一个问题是 NP 完全的，也有其求解方法。解决 NP 完全问题至少有三种方法：&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果实际输入数据规模较小，则用指数级运行时的算法就能很好地解决问题；&lt;/li&gt;
&lt;li&gt;对于一些能在多项式时间内解决的特殊情况，可以把它们单独列出来求解；&lt;/li&gt;
&lt;li&gt;可以寻找一些能够在多项式时间内得到近似最优解 （near-optimal solution)的方法(最坏情况或平均情况)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际应用中，近似最优解一般都能满足要求， 返回近似最优解的算法就称为近似算法(approximation algorithm)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;近似比：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果对规模为n的任意输人，近似算法所产生的近似解的代价C与最优解的代价C*只差一个因子$\rho (n)$:&lt;/p&gt;
&lt;p&gt;$$max(\frac{C}{C*},\frac{C*}{C} )\leq \rho (n)$$&lt;/p&gt;
&lt;p&gt;则称该近似算法有近似比$\rho (n)$。如果一个算法的近似比达到 $\rho (n)$，则称该算法为$\rho (n)$近似算法。近似比和$\rho (n)$近似算法的定义对求最大化和最小化问题都适用，一个近似算法的近似比不会小于1。&lt;/p&gt;
&lt;h1 id=&quot;一维装箱问题-Bin-Packing&quot;&gt;&lt;a href=&quot;#一维装箱问题-Bin-Packing&quot; class=&quot;headerlink&quot; title=&quot;一维装箱问题(Bin Packing)&quot;&gt;&lt;/a&gt;一维装箱问题(Bin Packing)&lt;/h1&gt;&lt;p&gt;问题如下：&lt;/p&gt;
&lt;p&gt;Bin Packing is as follows: Given n items with sizes $a_1, \cdots , a_n ∈ (0, 1]$, find a packing in unit-sized bins that minimizes the number of bins used.&lt;/p&gt;
&lt;p&gt;Give a 2-approximation algorithm for this problem and analysis the approximation factor.&lt;/p&gt;
&lt;p&gt;装箱问题：有n个物品，每个物品的尺寸在0-1之间，每个箱子的容量为1，问最少要用多少的箱子能把所有的物品装下？&lt;/p&gt;
&lt;p&gt;装箱问题可用整数规划描述如下，其中$y&lt;em&gt;i=1$表示箱子$i$被使用，否则表示没有使用，$x&lt;/em&gt;{ij}=1$表示物品j放入箱子i中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/VPewCSm.png&quot; style=&quot;display:block;margin:auto&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中约束条件(1)表示：一旦箱子i被使用，放入箱子i中的物品尺寸不能超过箱子的容量1。&lt;/p&gt;
&lt;p&gt;约束条件(2)表示：每个物品刚好放入一个箱子中。&lt;/p&gt;
&lt;p&gt;由&lt;a href=&quot;http://buptldy.github.io/2016/01/11/NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E8%AF%81%E6%98%8E/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;前文&lt;/a&gt;已知，整数线性规划问题是NP完全的，即不能找到多项式时间算法来求解，所以需要寻找一种近似算法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Next Fit算法：按顺序把物品放进当前箱子，如果放不下，则放下一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;物品&lt;/th&gt;
&lt;th&gt;$J_1$&lt;/th&gt;
&lt;th&gt;$J_2$&lt;/th&gt;
&lt;th&gt;$J_3$&lt;/th&gt;
&lt;th&gt;$J_4$&lt;/th&gt;
&lt;th&gt;$J_5$&lt;/th&gt;
&lt;th&gt;$J_6$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;尺寸&lt;/td&gt;
&lt;td&gt;0.6&lt;/td&gt;
&lt;td&gt;0.7&lt;/td&gt;
&lt;td&gt;0.4&lt;/td&gt;
&lt;td&gt;0.2&lt;/td&gt;
&lt;td&gt;0.8&lt;/td&gt;
&lt;td&gt;0.3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;根据Next Fit算法，解如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/YDnGdKS.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：Next Fit是Bin Packing问题近似比为2的近似算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对所有的输入物品序列I有:$NF(I) \leq 2OPT(I)$&lt;/p&gt;
&lt;p&gt;  如下图所示，任意考虑两个相邻的箱子，这两个箱子里面的物品的容量肯定要大于1，否则根据Next Fit算法会把这些物品放进第一个箱子，所以两个相邻箱子所占用的空间肯定是大于1的，即有$B_1+B_2&amp;gt;1$，对于$B_3+B_4,\dots$都是这样。因此浪费的空间不达到一半，所以有$NF(I) \leq 2OPT(I)$。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;br&gt;    &lt;img src=&quot;http://i.imgur.com/A8GpRKX.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;存在一个输入物品序列I：$NF(I)\geq 2OPT(I)-2$&lt;/p&gt;
&lt;p&gt;  考虑长度为n(n为4的倍数)的物品序列I，尺寸大小分别为：&lt;/p&gt;
&lt;p&gt;  0.5，2/n，0.5，2/n，…，0.5，2/n&lt;/p&gt;
&lt;p&gt;  则最佳装箱策略如下图所示，最少需要(n/4+1)个箱子。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://i.imgur.com/IPg1QX9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  Next Fit策略如下图所示，需要(n/2)个箱子&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://i.imgur.com/EkthQ3j.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  所以根据上述证明，Next Fit是Bin Packing问题近似比为2的近似算法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;复杂度分析&lt;/strong&gt;：由于NF算法处理每个物品只检查一个箱子,所以其时间复杂度是线性的,但也正因为如此,使得前面箱子剩余空间再无利用的可能。该算法的时间复杂度是 $O(n)$ , 空间复杂度为 $O(1)$ 。&lt;/p&gt;
&lt;h1 id=&quot;Steiner-Tree-Problem&quot;&gt;&lt;a href=&quot;#Steiner-Tree-Problem&quot; class=&quot;headerlink&quot; title=&quot;Steiner Tree Problem&quot;&gt;&lt;/a&gt;Steiner Tree Problem&lt;/h1&gt;&lt;p&gt;问题如下：&lt;/p&gt;
&lt;p&gt;Given an undirected graph G = (V, E) with edge costs and set T ⊆ V of required vertices, the Steiner Tree Problem is to find a minimum cost tree in G containing every vertex in T (vertices in V −T may or may not be used in T).&lt;/p&gt;
&lt;p&gt;Give a 2-approximation algorithm if G is complete and the edge costs satisfy the triangle inequality.&lt;/p&gt;
&lt;p&gt;所谓的Steine​​r tree problem是指在一无向图G(V,E)中, 给定一组V的子集合S, 我们要在其中找到一个minimum cost tree, 这个tree 必需包含S中所有的点, 另外也可包含一些非S中的点。这些非S的点我们称之为Steine​​r nodes, S中的点我们称之为terminals。&lt;/p&gt;
&lt;p&gt;Steine​​r tree problem 是属于NP-complete 的间题, 代表着我们目前找不到一个算法, 能够在polynomial 的时间内解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题详述:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/TF3lU8i.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;所谓的Steine​​r Tree Problem, 是一组无向图G(V,E)中, 给定一组terminals, 如图一的A和D, 然后我们必需在G上找到一个minimum spanning tree, 这个tree 必需满足下面要求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它必需span 所有的terminals&lt;/li&gt;
&lt;li&gt;它可以包含非terminal 的点, 这些点称之为steine​​r node, 如图1的B, E, F&lt;/li&gt;
&lt;li&gt;它的total cost必需为最小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上图中我们可以知道, 如果不能包含非terminal 的点, 则找出来的spanning tree, cost为6, 而且有可能根本找不到这样的tree, 在包含了一些steine​​r node 之后, 所找出的cost为5。&lt;br&gt;&lt;strong&gt;近似算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The Kou Markowsky and Berman algorithm&lt;/p&gt;
&lt;p&gt;Input: a undirect graph G(V,E) and a subset S of V.&lt;/p&gt;
&lt;p&gt;Output: The minimum cost Steine​​r tree T.&lt;/p&gt;
&lt;p&gt;Step1:建构distance graph G1(S, E’). 对每一个E’中的edge (u, v),它的cost等于G中u到v的最短路径的cost&lt;/p&gt;
&lt;p&gt;Step2: 找出minimum spaning tree T1 of G1&lt;/p&gt;
&lt;p&gt;Step3: 建构G2(V’’, E’’), 将T1的每一个edge (u, v), 用它在Step1中所找的路径代入.&lt;/p&gt;
&lt;p&gt;Step4: 将G2中的cycle去掉.&lt;/p&gt;
&lt;center&gt;&lt;br&gt;  &lt;img src=&quot;http://i.imgur.com/CohPHo2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;



&lt;p&gt;如上图所示, 首先我们先建立一个包含所有terminal 的complete distance graph G1, 然后找出它的minimum spanning tree T1, 然后将原路径代回, 得到G2, 最后将G2 的cycle移去, 得到total cost 为14 的Steine​​r Tree T. 因为此一近似算法为approximate algorithm, 所以它得到的steine​​r tree并一定都是optimum, 此例子的minimum Steine​​r tree的cost为13。&lt;/p&gt;
&lt;p&gt;复杂度和近似比：因为需要计算最短路径，所以时间复杂度为$O(M*N^2)$,其中 $|V|=N$ , $|S|=M$。&lt;/p&gt;
&lt;p&gt;近似比为2，证明可以参考：&lt;a href=&quot;http://www.csie.ntu.edu.tw/~kmchao/tree10fall/Steiner.pdf&quot; title=&quot;http://www.csie.ntu.edu.tw/~kmchao/tree10fall/Steiner.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.csie.ntu.edu.tw/~kmchao/tree10fall/Steiner.pdf&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;演算法设计与分析Term Project：&lt;a href=&quot;http://par.cse.nsysu.edu.tw/~homework/algo01/9034811/Report/index.htm&quot; title=&quot;演算法设计与分析Term Project&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://par.cse.nsysu.edu.tw/~homework/algo01/9034811/Report/index.htm&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;许多具有卖际意义的问题都是 &lt;a href=&quot;http://buptldy.github.io/2016/01/11/NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E8%AF%81%E6%98%8E/&quot;&gt;NP 完全&lt;/a&gt;问题。我们不知道如何在多项式时间内求得最优解。但是，这些问题通常又十分重要， 我们不能因此而放弃对它们的求解。即使一个问题是 NP 完全的，也有其求解方法。解决 NP 完全问题至少有三种方法：&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>NP完全性</title>
    <link href="http://yoursite.com/2016/01/11/2016-01-11-NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E8%AF%81%E6%98%8E/"/>
    <id>http://yoursite.com/2016/01/11/2016-01-11-NP完全问题的介绍及证明/</id>
    <published>2016-01-11T02:00:00.000Z</published>
    <updated>2016-03-14T05:28:33.393Z</updated>
    
    <content type="html">&lt;h1 id=&quot;NP完全性&quot;&gt;&lt;a href=&quot;#NP完全性&quot; class=&quot;headerlink&quot; title=&quot;NP完全性&quot;&gt;&lt;/a&gt;NP完全性&lt;/h1&gt;&lt;p&gt;  到目前为止，我们讨论的几乎都是&lt;strong&gt;多项式时间算法&lt;/strong&gt;：对于规模n的输入，在最坏情况下的运行时间是 $O(n^k)$ ,其中k为某一确定常数。但还有很多问题在多项式时间内并不能求解，根据能否在多项式时间求解，定义如下几类问题：&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;  P: 能在多项式时间内解决的问题&lt;/p&gt;
&lt;p&gt;  NP:不能在多项式时间内解决或不确定能不能在多项式时间内解决，但能在多项式时间验证的问题&lt;/p&gt;
&lt;p&gt;  NPC:NP完全问题，所有NP问题在多项式时间内都能约化(Reducibility)到它的NP问题，即解决了此NPC题，所有NP问题也都得到解决。&lt;/p&gt;
&lt;p&gt;  NP难问题:所有NP问题在多项式时间内都能约化(Reducibility)到它的问题(不一定是NP问题)。&lt;/p&gt;
&lt;p&gt;  如果任何NP完全问题是可以多项式求解的，则P=NP，目前还不能证明P是否等于NP，这几个问题的关系如下：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://i.imgur.com/mAyE7SM.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  规约的概念：若我们拥有一个已证明难以解决的问题，我们又获得另一个相似的新问题。我们可合理推想此新问题亦是难以解决的。我们可由下列谬证法得证：若此新问题本质上容易解答，且若我们可展示每个旧问题的实例可经由一系列转换步骤变成新问题的实例，则旧问题便容易解决，因此得到悖论。因此新问题可知亦难以解决。&lt;/p&gt;
&lt;p&gt;  如何证明某个问题是NP完全的？&lt;/p&gt;
&lt;p&gt;  如果我们有一个已经证明的NP完全问题，如果我们可以把已证明的NP完全问题的任何实例都能多项式的规约到要要证明问题的实例，则能证明这个问题是NP完全的。即如果我们要证明一个问题A是NPC问题，则只需要首先证明他是NP问题，然后只要找一个你所知道的NPC问题规约到A即可。&lt;/p&gt;
&lt;h1 id=&quot;常见的NPC问题&quot;&gt;&lt;a href=&quot;#常见的NPC问题&quot; class=&quot;headerlink&quot; title=&quot;常见的NPC问题&quot;&gt;&lt;/a&gt;常见的NPC问题&lt;/h1&gt;&lt;p&gt;  布尔可满足性问题（SAT）&lt;/p&gt;
&lt;p&gt;  对于一个确定的逻辑电路，是否存在一种输入使得输出为真。是第一个被证明的NPC问题，直观的看出这应该是一个NPC问题，因为当电路有k个输入，就会有$2^k$种情况的不同取值。&lt;br&gt;  3SAT&lt;/p&gt;
&lt;p&gt;  3和取范式：公式中每个字句都恰好有三个不同的’文字’，3SAT问题就是满足3和取范式的布尔公式是否可满足，3SAT问题可由SAT问题规约而来。&lt;br&gt;  分团问题（clique problem）&lt;/p&gt;
&lt;p&gt;  无向图中的团是图中所有顶点的一个子集，团中的每一对顶点之间都有一条边相连，即一个团就是无向图中的一个完全子图。&lt;/p&gt;
&lt;p&gt;  分团问题就是要寻找图中规模最大的团，判定条件：在图中是否存在一个给定规模为k的团。&lt;/p&gt;
&lt;p&gt;  独立集问题（Independent Set）&lt;/p&gt;
&lt;p&gt;  独立集：如果有一个顶点集合S，S中的任意两个顶点之间都没有边相连，则称S为一个独立集。&lt;/p&gt;
&lt;p&gt;  独立集问题和分团问题可相互规约，因为存在一个大小是k以上的分团，等价于它的补图中存在一个大小是k以上的独立集。&lt;/p&gt;
&lt;p&gt;  补图：一个图G的补图（complement）或者反面（inverse）是一个图有着跟G相同的点，而且这些点之间有边相连当且仅当在G里面他们没有边相连。在制作图的时候，你可以先建立一个有G所有点的完全图，然后清除G里面已经有的边来得到补图，这里的补图并不是图本身的补集。&lt;/p&gt;
&lt;p&gt;  顶点覆盖问题（Vertex Cover）&lt;/p&gt;
&lt;p&gt;  图的顶点覆盖是一些顶点的集合，使得图中的每一条边都至少接触集合中的一个顶点，如下图所示，图中红色顶点可以覆盖图中所有的边。寻找最小的顶点覆盖的问题称为顶点覆盖问题，它是一个NP完全问题。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://i.imgur.com/9wD7p7i.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;集合覆盖问题&quot;&gt;&lt;a href=&quot;#集合覆盖问题&quot; class=&quot;headerlink&quot; title=&quot;集合覆盖问题&quot;&gt;&lt;/a&gt;集合覆盖问题&lt;/h1&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;NP完全性&quot;&gt;&lt;a href=&quot;#NP完全性&quot; class=&quot;headerlink&quot; title=&quot;NP完全性&quot;&gt;&lt;/a&gt;NP完全性&lt;/h1&gt;&lt;p&gt;  到目前为止，我们讨论的几乎都是&lt;strong&gt;多项式时间算法&lt;/strong&gt;：对于规模n的输入，在最坏情况下的运行时间是 $O(n^k)$ ,其中k为某一确定常数。但还有很多问题在多项式时间内并不能求解，根据能否在多项式时间求解，定义如下几类问题：&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>网络最大流 [Max Flow]</title>
    <link href="http://yoursite.com/2016/01/10/2016-01-10-%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    <id>http://yoursite.com/2016/01/10/2016-01-10-网络最大流/</id>
    <published>2016-01-10T02:00:00.000Z</published>
    <updated>2016-03-14T09:04:49.500Z</updated>
    
    <content type="html">&lt;h1 id=&quot;网络流的定义&quot;&gt;&lt;a href=&quot;#网络流的定义&quot; class=&quot;headerlink&quot; title=&quot;网络流的定义&quot;&gt;&lt;/a&gt;网络流的定义&lt;/h1&gt;&lt;p&gt;在图论中，网络流（Network flow）是指在一个每条边都有容量（capacity）的有向图上分配每条路劲流量，使一条边的流量不会超过它的容量。通常在运筹学中，有向图称为网络。顶点称为节点（node）而边称为弧（arc）。一道流必须符合一个结点的进出的流量相同的限制，除非这是一个源点（source）──有较多向外的流，或是一个汇点（sink）──有较多向内的流。一个网络可以用来模拟道路系统的交通量、管中的液体、电路中的电流或类似一些东西在一个结点的网络中游动的任何事物。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设 G = (V,E) 是一个有限的有向图，它的每条边$ \ (u,v) \in E $ 都有一个非负值实数的容量$c(u, v)$。如果$(u, v) \not \in E$，我们假设 $c(u, v) = 0$。我们区别两个顶点：一个源点 s 和一个汇点 t 。一道网络流是一个对于所有结点 u 和 v 都有以下特性的实数函数 $f:$：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;容量限制（Capacity Constraints）：    $f(u, v) \le c(u, v)$一条边的流不能超过它的容量。&lt;/p&gt;
&lt;p&gt;流量守恒（Flow Conservation）：    除非u = s或u = t，否则 $\sum_{w \in V} f(u, w) = 0$，中间结点的流入等于流出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即流守恒意味着： $\sum&lt;em&gt;{(u,v) \in E} f(u,v) = \sum&lt;/em&gt;{(v,z) \in E} f(v,z) $，对每个顶点${v \in V\setminus{s,t}}$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大流问题&lt;/strong&gt;就是，给定一个流网络G，一个源节点s，一个汇点t，我们希望找到值最大的一个流。&lt;/p&gt;
&lt;p&gt;一个网络流如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/a8NFZl3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;网络最大流算法&quot;&gt;&lt;a href=&quot;#网络最大流算法&quot; class=&quot;headerlink&quot; title=&quot;网络最大流算法&quot;&gt;&lt;/a&gt;网络最大流算法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Ford-Fulkerson算法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;残存网络的概念：&lt;/p&gt;
&lt;p&gt;边的残存容量（residual capacity）是$ c_f(u, v) = c(u, v) - f(u, v)$。&lt;/p&gt;
&lt;p&gt;定义 $G_f(V, E_f)$ 表示剩余网络（residual network），它显示当前网络可用的容量的多少。就算在原网络中由 u 到 v 没有边，在剩余网络仍可能有由 u 到 v 的边。因为残存网络允许相反方向的流抵消，减少由 v 到 u 的流相当于增加由 u 到 v 的流，因为我们是为了求最大流，之前走过的路可能是走错的。&lt;/p&gt;
&lt;p&gt;增广路（augmenting path）是一条路径 $(u_1, u_2, \dots, u_k)$，而&lt;/p&gt;
&lt;p&gt; $u_1 = s , u_k = t $ 及&lt;br&gt; $c_f(u&lt;em&gt;i , u&lt;/em&gt;{i+1})&amp;gt;0$&lt;/p&gt;
&lt;p&gt; ，如果存在增广路，这表示沿这条路径还能够传送更多流。当且仅当剩余网络$G_f$ 没有增广路时处于最大流。&lt;/p&gt;
&lt;p&gt;建立残存网络$\ G_f$的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\ G_f = \ V $ 的顶点&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义如下的 $\ G_f = \ E_f$ 的边,对每条边 $\ (x,y) \in E$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若$\ f(x,y) &amp;lt; c(x,y)$，建立容量为$\ c_f = c(x,y) - f(x,y)$ 的前向边$\ (x,y) \in E_f$。&lt;/li&gt;
&lt;li&gt;若$\ f(x,y) &amp;gt; 0$，建立容量为$\ c_f =  f(x,y)$ 的后向边$\ (y, x) \in E_f$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上图中的残存网络如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/RS7lQTw.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最小割的概念：&lt;/p&gt;
&lt;p&gt;割的定义： 一个s-t 的割 C = (S, T) 把 所有的结点集合V分成两部分S和T，其中源节点s ∈ S 汇点 t ∈ T. 割 C 的集合表示如下：&lt;/p&gt;
&lt;p&gt;$${(u,v)\in E\:\ u\in S,v\in T}$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当割中的边被移掉时,则从源节点到汇结点的流量为0&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;割容量的定义：&lt;/p&gt;
&lt;p&gt;$$c(S,T)=\sum \nolimits&lt;em&gt;{(u,v)\in S\times T}c&lt;/em&gt;{uv}$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最大流最小割定理：当残存网络中不含有任何增广路径时，网络中的流量f最大且等于最小割容量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如下图所示，网络的最大流为7，最小割由图中虚线组成，其中最小割的容量也为7.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/7Q718mT.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Ford-Fulkerson算法求网络的最大流就是在每次的迭代中，寻找某条增广路径p，然后使用p来对流f进行修改，直到残存网络中不含有任何增广路径时，求得最大流f。&lt;/p&gt;
&lt;p&gt;Ford-Fulkerson算法伪代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/zsQkoBR.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/BUPTLdy/Algorithms/tree/master/Ford-Fulkerson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Ford-Fulkerson算法Python实现&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Push-relabel algorithm&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Push-Relabel系的算法普遍要比Ford-Fulkerson系的算法快，但是缺点是相对难以理解。详细内容可以参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm#Concepts&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;维基百科 Push–relabel maximum flow algorithm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/BUPTLdy/Algorithms/tree/master/Push-relabel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Push-relabel 算法Python实现&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;网络最大流问题建模&quot;&gt;&lt;a href=&quot;#网络最大流问题建模&quot; class=&quot;headerlink&quot; title=&quot;网络最大流问题建模&quot;&gt;&lt;/a&gt;网络最大流问题建模&lt;/h1&gt;&lt;p&gt;问题如下：&lt;/p&gt;
&lt;p&gt;Support the you are a matchmaker and there are some boys and girls. Since the boys are alway more than girls, you can assume that if a girl express her love to a boy , the boy will always accept her. Now you know every girl’s thought(a girl may like more than one boy) and you want to make as much pairs as you can. show that you can do this using maximum flow algorithm.&lt;/p&gt;
&lt;p&gt;题目意思大概是有一些男孩和女孩。男孩的数量大于等于女孩的数量，如果女孩向男孩表达爱意，男孩必定接受，假设你是个媒婆，而且你知道女孩们喜欢那个男孩(一个女孩可能同时喜欢多个男孩)，要你用最大流的方法求最多能匹配多少对？&lt;/p&gt;
&lt;p&gt;问题分析：最终一个女孩肯定只能和一个男孩配对，为了简单分析，我们假设有3个女孩${G_1,G_2,G_3}$，3个男孩${B_1,B_2,B_3}$,并且已知$G_1$喜欢$B_1$和$B_2$，$G_2$喜欢$B_2$,$G_3$喜欢$B_3$，我们可以构造出如下图所示的网络流：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/9hAGUgE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;求出上图所示网络的的最大流就是最大的匹配对数，根据这个思路，这个题抽象成最大流问题为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 源节点，汇点，以及每个女孩男孩都构成一个节点
- 如果某个女孩喜欢某些男孩，则把这个女孩和那些男孩相连
- 把源节点和每个女孩相连，汇结点和每个男孩相连
- 网络中所有相连边的容量为1
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;维基百科 网络流：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%B5%81&quot; title=&quot;维基百科 网络流&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%B5%81&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Wikipedia Max-flow min-cut theorem:&lt;a href=&quot;https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem&quot; title=&quot;Wikipedia Max-flow min-cut theorem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;网络流的定义&quot;&gt;&lt;a href=&quot;#网络流的定义&quot; class=&quot;headerlink&quot; title=&quot;网络流的定义&quot;&gt;&lt;/a&gt;网络流的定义&lt;/h1&gt;&lt;p&gt;在图论中，网络流（Network flow）是指在一个每条边都有容量（capacity）的有向图上分配每条路劲流量，使一条边的流量不会超过它的容量。通常在运筹学中，有向图称为网络。顶点称为节点（node）而边称为弧（arc）。一道流必须符合一个结点的进出的流量相同的限制，除非这是一个源点（source）──有较多向外的流，或是一个汇点（sink）──有较多向内的流。一个网络可以用来模拟道路系统的交通量、管中的液体、电路中的电流或类似一些东西在一个结点的网络中游动的任何事物。&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>线性规划 [Linear Programming]</title>
    <link href="http://yoursite.com/2016/01/09/2016-01-09-%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2016/01/09/2016-01-09-线性规划/</id>
    <published>2016-01-09T02:00:00.000Z</published>
    <updated>2016-03-14T09:32:59.400Z</updated>
    
    <content type="html">&lt;h1 id=&quot;什么是线性规划&quot;&gt;&lt;a href=&quot;#什么是线性规划&quot; class=&quot;headerlink&quot; title=&quot;什么是线性规划&quot;&gt;&lt;/a&gt;什么是线性规划&lt;/h1&gt;&lt;p&gt;线性规划（Linear Programming，简称LP）是指目标函数和约束条件皆为线性函数的最优化问题。&lt;/p&gt;
&lt;p&gt;线性规划问题的常用的最直观形式是标准型。标准型包括以下三个部分：&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个需要极大化的线性函数，例如：&lt;/p&gt;
&lt;p&gt;  $$c_1 x_1 + c_2 x_2$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以下形式的问题约束，例如：&lt;/p&gt;
&lt;p&gt;  $$a_{11} x&lt;em&gt;1 + a&lt;/em&gt;{12} x_2 \le b_1$$&lt;/p&gt;
&lt;p&gt;  $$a_{21} x&lt;em&gt;1 + a&lt;/em&gt;{22} x_2 \le b_2$$&lt;/p&gt;
&lt;p&gt;  $$a_{31} x&lt;em&gt;1 + a&lt;/em&gt;{32} x_2 \le b_3$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非负变量，例如：&lt;/p&gt;
&lt;p&gt;  $$x_1 \ge 0 $$&lt;/p&gt;
&lt;p&gt;  $$x_2 \ge 0 $$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;几个概念和定理介绍：&lt;/p&gt;
&lt;p&gt;可行域：下图中蓝色部分的点都是线性规划问题的解(可行解)，蓝色区域是可行解的集合，称为可行域。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/0QzN1q2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;基可行解：出现在可行域顶点的可行解&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定理1 若线性规划问题存在可行域，则其可行域是&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%87%B8%E9%9B%86&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;凸集&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;定理2 若可行域有界，线性规划问题的目标函数一定可以在其可行域的顶点上达到最优&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过上述定理得知，线性规划问题的解一定出现在可行域的顶点上，所以可以通过枚举所有的基可行解来找到最优解，但当变量个数很多时，这种办法是行不通的。&lt;/p&gt;
&lt;h1 id=&quot;单纯形法&quot;&gt;&lt;a href=&quot;#单纯形法&quot; class=&quot;headerlink&quot; title=&quot;单纯形法&quot;&gt;&lt;/a&gt;单纯形法&lt;/h1&gt;&lt;p&gt;单纯形法是求解线性规划问题的通用方法。单纯形是美国数学家G.B.丹齐克于1947年首先提出来的。它的理论根据是：线性规划问题的可行域是$n$维向量空间$R_n$中的多面凸集，其最优值如果存在必在该凸集的某顶点处达到。顶点所对应的可行解称为基本可行解。&lt;/p&gt;
&lt;p&gt;单纯形法的基本思想是：先找出一个基本可行解，对它进行鉴别，看是否是最优解；若不是，则按照一定法则转换到另一改进的基本可行解，再鉴别；若仍不是，则再转换，按此重复进行。因基本可行解的个数有限，故经有限次转换必能得出问题的最优解。如果问题无最优解也可用此法判别。&lt;/p&gt;
&lt;p&gt;单纯形法的一般解题步骤可归纳如下：&lt;/p&gt;
&lt;p&gt;①把线性规划问题的约束方程组表达成典范型方程组，找出基本可行解作为初始基可行解。&lt;/p&gt;
&lt;p&gt;②若基本可行解不存在，即约束条件有矛盾，则问题无解。&lt;/p&gt;
&lt;p&gt;③若基本可行解存在，从初始基本可行解作为起点，根据最优性条件和可行性条件，引入非基变量取代某一基变量，找出目标函数值更优的另一基本可行解。&lt;/p&gt;
&lt;p&gt;④按步骤③进行迭代,直到对应检验数满足最优性条件（这时目标函数值不能再改善），即得到问题的最优解。&lt;/p&gt;
&lt;p&gt;⑤若迭代过程中发现问题的目标函数值无界，则终止迭代。&lt;/p&gt;
&lt;p&gt;过程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/UfuthIQ.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wenku.baidu.com/view/0edfb06aaf1ffc4ffe47acec.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;单纯形法求解-动态演示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;单纯形法伪代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/lhxj168.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/BUPTLdy/Algorithms/tree/master/Simplex%20Algorithm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;单纯形法Python实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解线性规划问题也一些很好的工具，比如&lt;a href=&quot;https://www.gnu.org/software/glpk/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GLPK&lt;/a&gt;和&lt;a href=&quot;http://www.gurobi.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gurobi&lt;/a&gt;等。&lt;/p&gt;
&lt;h1 id=&quot;线性规划解决实际问题&quot;&gt;&lt;a href=&quot;#线性规划解决实际问题&quot; class=&quot;headerlink&quot; title=&quot;线性规划解决实际问题&quot;&gt;&lt;/a&gt;线性规划解决实际问题&lt;/h1&gt;&lt;p&gt;问题如下：&lt;/p&gt;
&lt;p&gt;with human lives at stake, an air traffic controller has to schedule the airplanes that are landing at an airport in order to avoid airplane collision. Each airplane $i$ has a time window $[s_i,t_i]$ during which it can safely land. You must compute the exact time of landing for each airplane that respects these time windows. Furthermore, the airplane landings should be stretched out as much as possible so that the minimum time gap between successive landings is as large as possible. For example, if the time window of landing three airplanes are [10:00-11:00], [11:20-11:40], [12:00-12:20], and they land at 10:00, 11:20, 12:20 respectively, then the smallest gap is 60 minutes, which occurs between the last two airplanes. Given n time windows, denoted as [s_1,t_1], [s_2,t_2], · · ·, [s_n,t_n] satisfying s_1 &amp;lt;t_1 &amp;lt; s_2 &amp;lt; t_2 &amp;lt; · · · &amp;lt; s_n &amp;lt; t_n, you are required to give the exact landing time of each airplane, in which the smallest gap between successive landings is maximized.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Please formulate this problem as an LP.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;题目的大概意思是每架飞机都只能在自己固定的时间窗内降落，为了安全起见两架飞机之间的降落时间间隔越大越好，然后给你n架飞机的降落时间窗口，要求n架飞机的最小降落间隔的最大值。&lt;/p&gt;
&lt;p&gt;这个问题的建模起来很简单，令$x_i$表示第$i$架飞机的降落时间，则需要满足约束条件：&lt;/p&gt;
&lt;p&gt;$$s_i\leq x_i \leq t_i$$&lt;/p&gt;
&lt;p&gt;然后我们的目标是要求最小间隔的最大值，所以我们的目标函数为：&lt;/p&gt;
&lt;p&gt;$$max(min(x_{i+1}-x_i))$$&lt;/p&gt;
&lt;p&gt;那么现在问题来了，我们上面所说的线性规划的标准形式是不包括既有max又有min的，所以我们需要把这个min去掉，我们可以通过引入一个新变量，如果有&lt;br&gt;  $y\leq x&lt;em&gt;{i+1}-x&lt;/em&gt;{i}$，那么$y$不就是$x&lt;em&gt;{i+1}-x&lt;/em&gt;{i}$的最小值吗？&lt;/p&gt;
&lt;p&gt;所以最终我们可以把问题形式化为:&lt;/p&gt;
&lt;p&gt;  $$    max &amp;amp; y &amp;amp; \&lt;br&gt;          s.t.&amp;amp; s_i\leq x_i \leq t&lt;em&gt;i&amp;amp; i=1,2,3 \cdots n\&lt;br&gt;         &amp;amp; y\leq x&lt;/em&gt;{i+1}-x_i &amp;amp; i=1,2,3 \cdots n$$&lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;维基百科 线性规划：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92&quot; title=&quot;维基百科 线性规划&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;百度百科 单纯形法：&lt;a href=&quot;http://baike.baidu.com/subview/471090/471090.htm&quot; title=&quot;百度百科 单纯形法&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://baike.baidu.com/subview/471090/471090.htm&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是线性规划&quot;&gt;&lt;a href=&quot;#什么是线性规划&quot; class=&quot;headerlink&quot; title=&quot;什么是线性规划&quot;&gt;&lt;/a&gt;什么是线性规划&lt;/h1&gt;&lt;p&gt;线性规划（Linear Programming，简称LP）是指目标函数和约束条件皆为线性函数的最优化问题。&lt;/p&gt;
&lt;p&gt;线性规划问题的常用的最直观形式是标准型。标准型包括以下三个部分：&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法[greedy algorithm]</title>
    <link href="http://yoursite.com/2016/01/08/2016-01-08-%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2016/01/08/2016-01-08-贪心策略/</id>
    <published>2016-01-08T02:00:00.000Z</published>
    <updated>2016-03-14T09:13:13.850Z</updated>
    
    <content type="html">&lt;h1 id=&quot;贪心算法-greedy-algorithm&quot;&gt;&lt;a href=&quot;#贪心算法-greedy-algorithm&quot; class=&quot;headerlink&quot; title=&quot;贪心算法(greedy algorithm)&quot;&gt;&lt;/a&gt;贪心算法(greedy algorithm)&lt;/h1&gt;&lt;p&gt;贪心算法通过做出一系列的选择来求出问题的最优解。 在每个决策点，它做出在当时看来是最佳的选择。贪心算法可以说是&lt;a href=&quot;http://buptldy.github.io/2016/01/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;动态规划&lt;/a&gt;问题的一种特例，在学习贪心算法之前，必须先得了解动态规划算法。贪心算法总是做出局部最优的选择，并不能总能保证找到全局最优解，那我们怎么才能保证一个贪心算法能够求解一个最优化问题呢？&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;如果我们能够证明要解决的问题具有如下两个性质，那么我们向贪心算法迈出了重要一步。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;贪心选择性质&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最关键的要素是看问题是否具有贪心选择性质：如果我们可以通过做出局部最优选择来构造全局解。也就是说，在进行选择时，我们直接选择在当前问题看起来最优的情况，而不必考虑子问题的解。&lt;/p&gt;
&lt;p&gt;这也是贪心算法与动态规划的不同之处，动态规划中每次的选择依赖于子问题的解，因此通常使用自底向上的方式求解动态规划问题。在贪心算法中，我们总是做出当时看起来是最佳的选择，然后求解剩下的&lt;strong&gt;唯一子问题&lt;/strong&gt;。贪心算法在选择时可能依赖以前的选择，但不依赖任何将来的选择或者子问题的解。因此，&lt;strong&gt;动态规划算法是自底向上进行计算的，而每一个贪心算法通常时自顶向下的，进行一次又一次选择，将给定问题的实例变得更小。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最优子结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。此性质是能否应用动态规划和贪心算法的关键要素。当应用于贪心算法时，我们可以假定，&lt;strong&gt;通过对原问题应用贪心选择就可以得到子问题&lt;/strong&gt;，我们所要做的工作就是论证：将子问题的最优解与贪心选择组合在一起就能得到原始问题的最优解。&lt;/p&gt;
&lt;p&gt;经过上述描述，我们可以按如下步骤设计贪心算法：&lt;/p&gt;
&lt;p&gt;1.将最优化问题转化成这样的形式：对其做出一次选择后，只剩下一个子问题需要求解。&lt;/p&gt;
&lt;p&gt;2.证明做出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的。&lt;/p&gt;
&lt;p&gt;3.证明做出贪心选择后，剩余的子问题满足性质:其最优解与贪心选择组合即可得到原问题的最优解。&lt;/p&gt;
&lt;h1 id=&quot;问题举例：Havel-Hakimi定理&quot;&gt;&lt;a href=&quot;#问题举例：Havel-Hakimi定理&quot; class=&quot;headerlink&quot; title=&quot;问题举例：Havel-Hakimi定理&quot;&gt;&lt;/a&gt;问题举例：Havel-Hakimi定理&lt;/h1&gt;&lt;p&gt;Given a list of $n$ natural numbers $d_1, d_2,…,d_n$, show how to decide in polynomial time whether there exists an undirected graph G = (V, E) whose node degrees are precisely the numbers $d_1, d_2, \cdots , d_n$. G should not contain multiple edges between the same pair of nodes, or “ loop” edges with both endpoints equal to the same node.&lt;/p&gt;
&lt;p&gt;题目的大概意思是：给你一组数字序列，数字的大小为图的度，问这些数字的度能够构成一个图（无向无环图），如果可以，则称该序列是可图的。&lt;/p&gt;
&lt;p&gt;怎么用贪心算法分析：&lt;/p&gt;
&lt;p&gt;1.首先由无向图的性质分析，如果所有的度之和为奇数，显然不能构成无向图&lt;br&gt;2.如果最大的度比序列的长度还大，明显也不能构成图，因为就算所有的结点和它相连，度的值也为n-1小于n。&lt;br&gt;3.贪心选择:由&lt;strong&gt;非负数组成的非增序列&lt;/strong&gt; $s:d_1,d_2,\cdots,d_n（n&amp;gt;=2，d_1&amp;gt;=1$是可图的，当仅当序列&lt;/p&gt;
&lt;p&gt;$$s1:d_2-1,d&lt;em&gt;3-1,\cdots d&lt;/em&gt;{d&lt;em&gt;1+1}-1,d&lt;/em&gt;{d1+2},\cdots,d_n$$&lt;/p&gt;
&lt;p&gt;是可图的。序列s1中有n-1个非负数，s序列排在$d_1$之后的前$d_1$个数减1后构成s1中的前$d_1$个数。&lt;/p&gt;
&lt;p&gt;判定过程：一直循环直到当前序列出现负数（即不是可图的情况）或者当前序列全为0 （可图）时退出。&lt;/p&gt;
&lt;p&gt;怎么理解这个贪心选择：如果一个序列是可图的，则我们选择一个度最小的结点，然后去掉这个结点以及和这个结点相连接的边，那么剩下的结点还是可图的，当然反过来也是可以的，所以这符合贪心算法的条件，去点一个结点以及和它连接的边之后，只要判断剩下的子问题是不是可图，逐渐的减少问题的规模，直到求解。&lt;/p&gt;
&lt;p&gt;Havel-Hakimi定理伪代码:(注意下面伪代码中的sort()排序是从大到小排序)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/K3Qj1gw.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题举例：霍夫曼编码-Huffman-Coding&quot;&gt;&lt;a href=&quot;#问题举例：霍夫曼编码-Huffman-Coding&quot; class=&quot;headerlink&quot; title=&quot;问题举例：霍夫曼编码(Huffman Coding)&quot;&gt;&lt;/a&gt;问题举例：霍夫曼编码(Huffman Coding)&lt;/h1&gt;&lt;p&gt;霍夫曼编码的具体原理就不仔细介绍了，可以参考维基百科&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81&quot; title=&quot;霍夫曼编码&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;霍夫曼编码&lt;/a&gt;，主要在这里说说霍夫曼编码中怎么应用贪心算法。&lt;/p&gt;
&lt;p&gt;贪心选择：构造霍夫曼树的关键之处在于每一步执行的时候，并不知道这个低频率的字符会编码为多少，只能保证它在树的最下面，使用最长的编码，这样就不会影响频率高的字符的编码。而每一步贪心的过程，都将两个频率低的字符合成一个父字符，减小了问题的规模，这样这个策略就在不影响其它字符编码的情况下，不断缩小问题的规模，直到最终求解。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/BUPTLdy/Algorithms/tree/master/huffman&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;霍夫曼编码CPP代码下载&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;贪心算法如何体现在霍夫曼编码中？&lt;a href=&quot;https://www.zhihu.com/question/22112710/answer/56030576&quot; title=&quot;贪心算法如何体现在霍夫曼编码中？&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/22112710/answer/56030576&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;贪心算法-greedy-algorithm&quot;&gt;&lt;a href=&quot;#贪心算法-greedy-algorithm&quot; class=&quot;headerlink&quot; title=&quot;贪心算法(greedy algorithm)&quot;&gt;&lt;/a&gt;贪心算法(greedy algorithm)&lt;/h1&gt;&lt;p&gt;贪心算法通过做出一系列的选择来求出问题的最优解。 在每个决策点，它做出在当时看来是最佳的选择。贪心算法可以说是&lt;a href=&quot;http://buptldy.github.io/2016/01/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/&quot;&gt;动态规划&lt;/a&gt;问题的一种特例，在学习贪心算法之前，必须先得了解动态规划算法。贪心算法总是做出局部最优的选择，并不能总能保证找到全局最优解，那我们怎么才能保证一个贪心算法能够求解一个最优化问题呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="CPP" scheme="http://yoursite.com/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>动态规划[dynamic programming]</title>
    <link href="http://yoursite.com/2016/01/07/2016-01-07-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2016/01/07/2016-01-07-动态规划/</id>
    <published>2016-01-07T02:00:00.000Z</published>
    <updated>2016-03-14T09:21:35.329Z</updated>
    
    <content type="html">&lt;h1 id=&quot;动态规划-dynamic-programming&quot;&gt;&lt;a href=&quot;#动态规划-dynamic-programming&quot; class=&quot;headerlink&quot; title=&quot;动态规划(dynamic programming)&quot;&gt;&lt;/a&gt;动态规划(dynamic programming)&lt;/h1&gt;&lt;p&gt;动态规划与&lt;a href=&quot;http://buptldy.github.io/2016/01/06/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5%5BDivide%20and%20Conquer%5D/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;分治方法&lt;/a&gt;相似，都是通过组合子问题的接来求解原问题，分治方法是将问题划分为互不相交的子问题，递归的求解子问题，再将它们的解组合起来，求出原问题的解。动态规划与之相反，应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。在这种情况下，分治算法会反复的求解这些公共子问题，而动态规划对每个子问题只求解一次并保存结果，从而无需重复求解。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;通常动态规划被用来求解&lt;a href=&quot;https://en.wikipedia.org/wiki/Optimization_problem&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;最优化问题&lt;/a&gt;，即在可行解中寻找最优解。&lt;/p&gt;
&lt;p&gt;设计一个动态规划算法通常有如下4个步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (1).刻画一个最优解的结构特征
- (2).递归地定义最优解的值
- (3).采用自底向上的方法计算最优解的值
- (4).利用计算出的信息构造最优解
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果我们只需要得到这个最优解的结果，而不关注这个解是怎么得来的，则可以忽略步骤(4)。&lt;/p&gt;
&lt;p&gt;上面叙述了动态规划方法的步骤，但是什么问题才能够使用动态规划法求解？使用动态规划方法求解的最优化问题应该具备两个要素：最优子结构和子问题重叠。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最优子结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个问题的最优解包含其子问题的最优解，则称此问题具有最优子结构性质。在动态规划方法中，我们通常自底向上地使用最优子结构，即首先求得子问题的最优解，然后求原问题的最优解。&lt;strong&gt;原问题的最优解的代价通常就是子问题最优解的代价再加上由此次选择直接产生的代价。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子问题重叠&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果递归算法反复求解相同的子问题，就称最优化问题具有重叠子问题。动态规划算法通常这样利用重叠子问题性质：&lt;strong&gt;对每个子问题求解一次，将解存入一个表中，当再次需要这个子问题时直接查表，每次查表的代价为常量时间。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题举例：Money-robbing&quot;&gt;&lt;a href=&quot;#问题举例：Money-robbing&quot; class=&quot;headerlink&quot; title=&quot;问题举例：Money robbing&quot;&gt;&lt;/a&gt;问题举例：Money robbing&lt;/h1&gt;&lt;p&gt;问题如下所示：&lt;/p&gt;
&lt;p&gt;A robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.&lt;/li&gt;
&lt;li&gt;What if all houses are arranged in a circle?&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;大概意思就是街上有一排房子，有个房子里有一定数量的钱，如果小偷在同一天晚上偷了两座相邻的房子，就会触发警报系统，第一问就是问在小偷不触发警报系统的前提下，怎样偷到的钱最多。&lt;/p&gt;
&lt;p&gt;动态规划问题最重要的就是求出递归式，把原问题的最优化化为子问题的最优化。对这个问题来说，唯一的约束条件是不能同时抢劫相邻的两座房子，假设共有n座房子，分两种情况讨论：&lt;/p&gt;
&lt;p&gt;(1). 如果你抢劫了第n座房子，很明显你能得到第n座房子的钱，但你只能抢劫第n-2座房子了，因为你不想被抓起来；&lt;/p&gt;
&lt;p&gt;(2). 此时不选择抢劫第n座房子，当然待会你就可以抢劫第n-1座房子了&lt;/p&gt;
&lt;p&gt;但这两种选择哪种是最优的了，很明显取决与这两个子问题的最优解，所以我们把原问题的最优解化成求解子问题的最优解，根据上述两种情况划分，可以很容易的写出递推公式：&lt;/p&gt;
&lt;p&gt;$$dp(n)=MAX{dp(n-1),dp(n-2)+money(n)}$$&lt;/p&gt;
&lt;p&gt;其中money(n)表示抢劫第n座房子得到的钱(注意在写程序是money[n-1],因为数组下标从0开始)，根据递推公式，采用自底向上的方法，就能计算出最优的结果。&lt;/p&gt;
&lt;p&gt;伪代码如下所示：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/MW11e6T.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;再来看第二问，第二问的意思就是如果房子不是排成一排而是围成一圈，该怎样才能偷到最多的钱？&lt;br&gt;我们随机的从一圈n座房子中选中一座房子，现在我们面临两个选择，抢还是不抢？&lt;/p&gt;
&lt;p&gt;(1) 假设我们选择抢劫这座房子，当然我们能得到这座房子的钱，但是为了避免触发警报我们不能抢劫它周围的两座房子了，那么剩下的n-3座房子就没有构成一个圈了，那么问题也就规约成第一问的情况了；&lt;br&gt;(2) 假如我们没有抢劫这座房子，那么去掉这座房子，剩下的n-1座房子不是就不构成圈了吗，所以还是回到第一问的问题。&lt;/p&gt;
&lt;p&gt;经过分析，所以我们得到递推公式为:&lt;/p&gt;
&lt;p&gt;$$dp_{circle(n)}=MAX{dp(n-1),dp(n-3)+money(n)}$$&lt;/p&gt;
&lt;h1 id=&quot;问题举例：Maximum-profit-of-transactions&quot;&gt;&lt;a href=&quot;#问题举例：Maximum-profit-of-transactions&quot; class=&quot;headerlink&quot; title=&quot;问题举例：Maximum profit of transactions&quot;&gt;&lt;/a&gt;问题举例：Maximum profit of transactions&lt;/h1&gt;&lt;p&gt;问题如下：&lt;/p&gt;
&lt;p&gt;Say you have an array for which the i-th element is the price of a given stock on day i.&lt;br&gt;Design an algorithm and implement it to find the maximum profit. You may complete at most two transactions.&lt;/p&gt;
&lt;p&gt;Note: You may not engage in multiple transactions at the same time (ie,you must sell the stock before you buy again).&lt;/p&gt;
&lt;p&gt;这个题目的意思是给你每天股票的价格，你能最多进行两次交易(一次交易包括买进和卖出)，怎样才能获得最大的收益。&lt;/p&gt;
&lt;p&gt;我们先来讨论只在一次交易的情况下，怎么求得收益最大化，其实这个问题就是给你一个数组，求出这组数里面不是&lt;a href=&quot;http://buptldy.github.io/2016/01/06/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5%5BDivide%20and%20Conquer%5D/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;逆序数&lt;/a&gt;(因为卖出肯定在买进之后)但相差最大的两个数的差,比如5，1，3，2，4中，以价钱1买进，价钱4卖出可以获得最大的收益3。&lt;/p&gt;
&lt;p&gt;我们用动态规划法来分析这个问题，通过自底向上的方法，分析如何从前i天的最大收益推出前i+1天的最大收益，已知前i天的最大收益和前i天的最低价格：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第i+1天的价格大于minPrice（已遍历数据的最低价），此时只要对max(i)（前i天的最大获益）和prices[i + 1] - minPrice（第i+1天卖出所能得到的获益）取大值就能得出max(i + 1)&lt;/li&gt;
&lt;li&gt;第i+1天的价格小于等于minPrice，那么在第i+1天卖出所得到的获益必然是小于max(i)（这里哪怕考虑极端情况：给出的数据是整体递减的，那么最佳的卖出时机也是当天买当天卖，获益为0，所以不会存在获益是负值的情况），所以max(i + 1) = max(i)。而且，对于之后的数据而言，minPrice需要更新了，因为对于之后的数据，在第i+1天买进必然比在0到i天之间的任何时候买进的获益都要多（因为第i+1天是0到i+1区间内的最低价）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以通过上述动态规划的方法可以求出只进行一次交易的最大收益，但我们题目中问的是最多进行两次交易的情况下，我们可以把Prices[] 分成两部分Prices[0…m] 和 Prices[m…length]  ，分别计算在这两部分内做交易的最大收益，方法就是上面所说的一次交易的方法，第一步扫描，先计算出子序列[0,…,i]中的最大利润，用一个数组保存下来，时间是O(n)。 第二步是逆向扫描，计算子序列[i,…,n-1]上的最大利润，这一步同时就能结合上一步的结果计算最终的最大利润了，这一步也是O(n)。 所以最后算法的复杂度就是O(n)。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/BUPTLdy/Algorithms/tree/master/Maximum%20profit%20of%20transactions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;算法代码下载(CPP)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;Best Time to Buy and Sell Stock I II III IV@LeetCode：&lt;a href=&quot;http://segmentfault.com/a/1190000002565570&quot; title=&quot;Best Time to Buy and Sell Stock I II III IV@LeetCode&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://segmentfault.com/a/1190000002565570&lt;/a&gt;&lt;br&gt;LeetCode-Best Time to Buy and Sell Stock系列：&lt;a href=&quot;http://www.tuicool.com/articles/rMJZj2&quot; title=&quot;LeetCode-Best Time to Buy and Sell Stock系列&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.tuicool.com/articles/rMJZj2&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态规划-dynamic-programming&quot;&gt;&lt;a href=&quot;#动态规划-dynamic-programming&quot; class=&quot;headerlink&quot; title=&quot;动态规划(dynamic programming)&quot;&gt;&lt;/a&gt;动态规划(dynamic programming)&lt;/h1&gt;&lt;p&gt;动态规划与&lt;a href=&quot;http://buptldy.github.io/2016/01/06/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5%5BDivide%20and%20Conquer%5D/&quot;&gt;分治方法&lt;/a&gt;相似，都是通过组合子问题的接来求解原问题，分治方法是将问题划分为互不相交的子问题，递归的求解子问题，再将它们的解组合起来，求出原问题的解。动态规划与之相反，应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。在这种情况下，分治算法会反复的求解这些公共子问题，而动态规划对每个子问题只求解一次并保存结果，从而无需重复求解。&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="CPP" scheme="http://yoursite.com/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>分治策略[Divide and Conquer]</title>
    <link href="http://yoursite.com/2016/01/06/2016-01-06-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5%5BDivide%20and%20Conquer%5D/"/>
    <id>http://yoursite.com/2016/01/06/2016-01-06-分治策略[Divide and Conquer]/</id>
    <published>2016-01-06T02:00:00.000Z</published>
    <updated>2016-03-14T09:25:56.030Z</updated>
    
    <content type="html">&lt;h1 id=&quot;分治法简介：&quot;&gt;&lt;a href=&quot;#分治法简介：&quot; class=&quot;headerlink&quot; title=&quot;分治法简介：&quot;&gt;&lt;/a&gt;分治法简介：&lt;/h1&gt;&lt;p&gt;使用分治法的前提是问题在结构上是&lt;strong&gt;递归&lt;/strong&gt;的，为了解决这一问题，算法一次或多次递归地调用自身以解决紧密相关的若干个子问题。&lt;/p&gt;
&lt;p&gt;分治模式在每层的递归时有三个步骤：&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- **分解**原问题为若干子问题，这些子问题是原问题规模较小的实例。
- **解决**这些子问题，递归的求解各子问题，当子问题规模最够小时，则直接求解。
- **合并**这些子问题的解得到原始问题的解
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;Karatsuba-算法&quot;&gt;&lt;a href=&quot;#Karatsuba-算法&quot; class=&quot;headerlink&quot; title=&quot;Karatsuba 算法&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Karatsuba_algorithm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Karatsuba&lt;/a&gt; 算法&lt;/h1&gt;&lt;p&gt;Karatsuba算法是一种快速乘法算法，在1960年由&lt;a href=&quot;https://en.wikipedia.org/wiki/Anatoly_Karatsuba&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Anatoly Karatsuba&lt;/a&gt;提出。普通乘法的复杂度是$O(n^2)$,而Karatsuba算法的时间复杂度为$O(n^{1.585})$。&lt;/p&gt;
&lt;p&gt;现在运用分治的思想来阐述下Karatsuba算法的基本原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分解：原本要计算两个大数x，y的乘法,先把x,y分解成如下两部分，其中B为基。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$x = x_1B^m + x_0$$&lt;/p&gt;
&lt;p&gt;$$y = y_1B^m + y_0$$&lt;/p&gt;
&lt;p&gt;其中 $x_0$ 和 $y_0$ 要小于 $B^m$。 现在$xy$可以写为:&lt;/p&gt;
&lt;p&gt;$$xy = (x_1B^m + x_0)(y_1B^m + y_0)$$&lt;br&gt;$$xy = z_2B^{2m} + z_1B^m + z_0$$&lt;br&gt;$$z_2 = x_1y_1$$&lt;br&gt;$$z_1 = x_1y_0 + x_0y_1$$&lt;br&gt;$$z_0 = x_0y_0$$&lt;/p&gt;
&lt;p&gt;原本上面的式子中一共需要计算4次乘法（与基的幂次相乘只要进行移位操作就行），但是注意到有：&lt;/p&gt;
&lt;p&gt;$$z_1 = (x_1 + x_0)(y_1 + y_0) - z_2 - z_0$$&lt;/p&gt;
&lt;p&gt;所以每次只需要计算三次乘法即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决：通过上述分解步骤，我们每次还是需要3次乘法运算，然而这三次乘法运算我们可以继续递归的调用Karatsuba算法，直到数字足够小可以直接运用普通乘法求解。&lt;/li&gt;
&lt;li&gt;合并：Karatsuba算法并没有涉及合并问题，通过公式$xy = z_2B^{2m} + z_1B^m + z_0$把最终结果求出来即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上述分析，当m=n/2时(n为乘数的长度)，递归的效率最高，所以递归公式为：&lt;/p&gt;
&lt;p&gt;$$T(n) = 3 T(\lceil n/2\rceil) + cn + d$$&lt;/p&gt;
&lt;p&gt;由递归公式根据&lt;a href=&quot;http://buptldy.github.io/2015/12/29/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B8%90%E8%BF%9B%E6%A0%87%E5%8F%B7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;主定理&lt;/a&gt;得到算法的复杂度为：&lt;/p&gt;
&lt;p&gt;$$T(n) = \Theta(n^{\log_2 3})$$&lt;/p&gt;
&lt;p&gt;Karatsuba算法伪代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;procedure karatsuba(num1, num2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			if (num1 &amp;lt; 10) or (num2 &amp;lt; 10)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return num1*num2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			/* calculates the size of the numbers */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			m = max(size_base10(num1), size_base10(num2))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		m2 = m/2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			/* split the digit sequences about the middle */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		high1, low1 = split_at(num1, m2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			high2, low2 = split_at(num2, m2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			/* 3 calls made to numbers approximately half the size */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			z0 = karatsuba(low1,low2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			z1 = karatsuba((low1+high1),(low2+high2))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			z2 = karatsuba(high1,high2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			return (z2*10^(2*m2))+((z1-z2-z0)*10^(m2))+(z0)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/BUPTLdy/Algorithms/tree/master/Karatsuba&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Karatsuba算法代码下载(CPP)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;归并排序-MergeSort&quot;&gt;&lt;a href=&quot;#归并排序-MergeSort&quot; class=&quot;headerlink&quot; title=&quot;归并排序(MergeSort)&quot;&gt;&lt;/a&gt;归并排序(MergeSort)&lt;/h1&gt;&lt;p&gt;还是根据分治策略的思想，分为三个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分解：把要排序的n个元素序列分解成两个含有n/2个元素的子序列&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/umuDsOg.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;解决：递归的调用分解，直到子序列能够直接排序&lt;/li&gt;
&lt;li&gt;合并：归并排好序的子序列，直到得到原始问题的解&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单例子演示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/33u5yyl.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;逆序数统计-Counting-Inversion&quot;&gt;&lt;a href=&quot;#逆序数统计-Counting-Inversion&quot; class=&quot;headerlink&quot; title=&quot;逆序数统计(Counting Inversion)&quot;&gt;&lt;/a&gt;逆序数统计(Counting Inversion)&lt;/h1&gt;&lt;p&gt;问题定义：输入n个不同的数字$a_1,a_2,\cdots ,a_n$，计算有多少对逆序数，逆序数的定义为数字下标$i&lt;j$但是数字$a_i&gt;a_j$。比如数字序列2，4，1，3，5，数字2在数字1的前面，但比数字1大，所以是一对逆序数，上述数字序列共有3组逆序数：（2，1），（4，1），（4，3）。&lt;/j$但是数字$a_i&gt;&lt;/p&gt;
&lt;p&gt;统计逆序数要用到分治的思想，我们能很容易能想到先分解成两个子序列然后再递归求解每个子序列的逆序数。&lt;/p&gt;
&lt;p&gt;现在主要的问题是解决，怎么计算两个不同子序列之间的逆序数，也就是怎么合并的问题，如下图所示，如果只是通过子序列之间每个数字的简单比较求解逆序数，则需要通过$n^2/4$次比较。所以时间复杂度为$T(n)=2T(n/2)+n^2/4=O(n^2)$(求解方法参考&lt;a href=&quot;http://buptldy.github.io/2015/12/29/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B8%90%E8%BF%9B%E6%A0%87%E5%8F%B7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;主定理&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/mDpKIUp.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;所以这样和直接暴力解法相比，时间复杂度比没有降低，这时我们通过前面的归并排序想到，如果我们先对子序列进行排序(对子序列排序并不会影响两个子序列之间的逆序数对)，再统计子序列之间的逆序数。统计方法如下图所示，两个排好序的子序列之间进行逆序数统计，比如说第一个序列的第一个数字3比第二个序列的第一个数字2要大，则第一个序列3后面的数字肯定都要比2要大，所以直接统计出逆序数为6，根据这种思想可以把子序列之间的所有逆序数统计出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/wJtHUMG.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;(gif generated by &lt;a href=&quot;https://screentogif.codeplex.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ScreenToGif&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;上述合并求解逆序数的方法，先给子序列排序并同时计算逆序数，花费$O(n)$的时间，所以问题总的时间复杂度为：&lt;/p&gt;
&lt;p&gt;$$T(n)=2T(n/2)+O(n)=O(nlogn)$$&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/BUPTLdy/Algorithms/tree/master/Counting%20Inversion&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Counting Inversion算法代码下载(CPP)&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分治法简介：&quot;&gt;&lt;a href=&quot;#分治法简介：&quot; class=&quot;headerlink&quot; title=&quot;分治法简介：&quot;&gt;&lt;/a&gt;分治法简介：&lt;/h1&gt;&lt;p&gt;使用分治法的前提是问题在结构上是&lt;strong&gt;递归&lt;/strong&gt;的，为了解决这一问题，算法一次或多次递归地调用自身以解决紧密相关的若干个子问题。&lt;/p&gt;
&lt;p&gt;分治模式在每层的递归时有三个步骤：&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="CPP" scheme="http://yoursite.com/tags/CPP/"/>
    
  </entry>
  
  <entry>
    <title>启发式图搜索策略</title>
    <link href="http://yoursite.com/2016/01/05/2016-01-05-%E5%90%AF%E5%8F%91%E5%BC%8F%E5%9B%BE%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2016/01/05/2016-01-05-启发式图搜索/</id>
    <published>2016-01-05T02:00:00.000Z</published>
    <updated>2016-03-14T09:27:32.235Z</updated>
    
    <content type="html">&lt;h1 id=&quot;什么是启发式搜索&quot;&gt;&lt;a href=&quot;#什么是启发式搜索&quot; class=&quot;headerlink&quot; title=&quot;什么是启发式搜索&quot;&gt;&lt;/a&gt;什么是启发式搜索&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://buptldy.github.io/2016/01/04/%E5%9B%BE%E6%90%9C%E7%B4%A2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;无信息图搜索&lt;/a&gt;一般需要产生大量的节点，因而效率较低。为提高效率，可以使用一些问题相关的信息，以减小搜索量，这些信息就称为启发式信息。使用启发式信息指导的搜索过程称为启发式搜索，所以启发式图搜索与无信息图搜索之间的区别就是启发式图搜索在OPEN表的排序过程中使用了与问题有关的知识。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;在启发式搜索过程中对OPEN表进行排序，就需要定义一个评价函数f(n)，对当前的搜索状态进行评估，找出一个&lt;em&gt;最有希望&lt;/em&gt;的节点来扩展。&lt;/p&gt;
&lt;h1 id=&quot;A算法&quot;&gt;&lt;a href=&quot;#A算法&quot; class=&quot;headerlink&quot; title=&quot;A算法&quot;&gt;&lt;/a&gt;A算法&lt;/h1&gt;&lt;p&gt;A算法是一种典型的启发式搜索算法，其基本思想为：定义一个评价函数f(n)，对当前的搜索状态进行评估，找出一个&lt;em&gt;最有希望&lt;/em&gt;的节点来扩展。&lt;br&gt;评价函数的形式为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f(n)=g(n)+h(n)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中n是被评价的结点。&lt;/p&gt;
&lt;p&gt;为了了解f(n),g(n),h(n)的含义，我们先来介绍一下几个函数的定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;g*(n):从s（初始结点）到n的最短路径的耗散值（相当于一条路径的费用，代价）&lt;/li&gt;
&lt;li&gt;h*(n):从n到g(目标结点)的最短路径的耗散值&lt;/li&gt;
&lt;li&gt;f*(n)=g*(n)+h*(n)：从s经过n到g的最短路径的耗散值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;g(n)、 h(n)、 f(n)分别是g*(n)、 h*(n)、 f*(n)的估计值,是一种预测。A算法就是利用这种预测，来达到搜索的目的。&lt;strong&gt;它每次按照f(n)值的大小对OPEN表中的元素进行排序，f值小的放前面，f值大的放后面&lt;/strong&gt;，这样每次在扩展结点时，总是选择当前f值最小的结点来优先扩展。&lt;/p&gt;
&lt;p&gt;要想根据f对OPEN表中的结点排序，就需要计算f(n),g(n)和h(n)的值，根据搜索结果，g(n)就是初始结点s到结点n这条路径的耗散值；而h(n)依赖于启发信息，取决于具体的问题，通常称其为启发函数。&lt;/p&gt;
&lt;h2 id=&quot;A算法举例：八数码问题（Eight-Puzzle）&quot;&gt;&lt;a href=&quot;#A算法举例：八数码问题（Eight-Puzzle）&quot; class=&quot;headerlink&quot; title=&quot;A算法举例：八数码问题（Eight-Puzzle）&quot;&gt;&lt;/a&gt;A算法举例：八数码问题（Eight-Puzzle）&lt;/h2&gt;&lt;p&gt;八数码问题也称为九宫问题。在3×3的棋盘，摆有八个棋子，每个棋子上标有1至8的某一数字，不同棋子上标的数字不相同。棋盘上还有一个空格，与空格相邻的棋子可以移到空格中。要求解决的问题是：给出一个初始状态和一个目标状态，找出一种从初始转变成目标状态的移动棋子步数最少的移动步骤。&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/XGw5X8W.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;设评价函数f(n)形式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f(n)=d(n)+W(n)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，d(n)代表结点的深度，在单位耗散的情况下g(n)=d(n);取h(n)=W(n)表示以‘不在位’棋子个数作为启发函数的度量。如上图所示，初始状态和目标状态相比，初始状态中的数字“1”，“2”，“6”，“8”不在目标状态的位置上，所以初始状态的h值为4。&lt;/p&gt;
&lt;p&gt;使用这种评价函数的搜索树如下所示，图中括弧中的数字表示该结点的评价函数值f;带圆圈的数字表示扩展结点的顺序。&lt;br&gt;    &lt;img src=&quot;http://i.imgur.com/8DgjWdD.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;根据目标结点L返回到s的指针，可得解路径为S(4)，B(4)，E(5)，I(5)，K(5)，L(5)。
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;A-算法&quot;&gt;&lt;a href=&quot;#A-算法&quot; class=&quot;headerlink&quot; title=&quot;A*算法&quot;&gt;&lt;/a&gt;A*算法&lt;/h1&gt;&lt;p&gt;最佳图搜索算法A*(optimal search)，在A算法中，如果有h(n)&amp;lt;=h*(n),则把这个算法称为A*算法。当问题有解时，&lt;strong&gt;A*算法一定能找到一条到达目标结点的最佳路径&lt;/strong&gt;。例如，当h(n)恒为零时，满足条件，此时若取g为深度值，则算法等同于宽度优先算法，在&lt;a href=&quot;http://buptldy.github.io/2016/01/04/%E5%9B%BE%E6%90%9C%E7%B4%A2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;无信息图搜索&lt;/a&gt;中已提到过，宽度优先算法能够找到一条到目标结点的最短路径。&lt;/p&gt;
&lt;p&gt;在使用A*算法求解问题时，定义的启发函数h，在满足A*的条件下，应尽可能的大一点，使其接近h*，这样才能提高搜索的效率，当h=h*时，搜索的效率最高。&lt;/p&gt;
&lt;p&gt;对于八数码问题，取h(n)=W(n),容易看出，尽管我们不知道h*(n)具体为多少，但是它肯定至少要移动W(n)步才能达到目标状态，因为W(n)为此时和目标状态不相同的数字个数，所以有h(n)&amp;lt;=h*(n),满足A*算法条件，所以上述A算法的例子也是A*算法。&lt;/p&gt;
&lt;h1 id=&quot;A-算法的改进&quot;&gt;&lt;a href=&quot;#A-算法的改进&quot; class=&quot;headerlink&quot; title=&quot;A*算法的改进&quot;&gt;&lt;/a&gt;A*算法的改进&lt;/h1&gt;&lt;p&gt;在A*算法中，扩展一个节点时，对已经在OPEN表或CLOSED表中的子节点，要调整指针，花时间和精力。如果在扩展节点n时，就已经找到了从根节点开始到它的最优路径，则不必调整指针, 可以大大提高效率。如果满足单调性限制，则可实现此愿望。&lt;/p&gt;
&lt;p&gt;如果对每一个节点$n_i$以及它的后继节点$n_j$，满足：&lt;/p&gt;
&lt;p&gt;$$h(n_i) - h(n_j) ≤ k(n_i,n_j)$$&lt;/p&gt;
&lt;p&gt;则称启发式函数满足单调性限制。&lt;/p&gt;
&lt;p&gt;如果A*满足单调性限制，则当它选择节点n扩展时，就已经发现了通向节点n的最佳路径,则不必进行结点的指针修正操作，因而改善了A*的效率。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是启发式搜索&quot;&gt;&lt;a href=&quot;#什么是启发式搜索&quot; class=&quot;headerlink&quot; title=&quot;什么是启发式搜索&quot;&gt;&lt;/a&gt;什么是启发式搜索&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://buptldy.github.io/2016/01/04/%E5%9B%BE%E6%90%9C%E7%B4%A2/&quot;&gt;无信息图搜索&lt;/a&gt;一般需要产生大量的节点，因而效率较低。为提高效率，可以使用一些问题相关的信息，以减小搜索量，这些信息就称为启发式信息。使用启发式信息指导的搜索过程称为启发式搜索，所以启发式图搜索与无信息图搜索之间的区别就是启发式图搜索在OPEN表的排序过程中使用了与问题有关的知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Artificial Intelligence" scheme="http://yoursite.com/tags/Artificial-Intelligence/"/>
    
  </entry>
  
  <entry>
    <title>无信息图搜索策略</title>
    <link href="http://yoursite.com/2016/01/04/2016-01-04-%E5%9B%BE%E6%90%9C%E7%B4%A2/"/>
    <id>http://yoursite.com/2016/01/04/2016-01-04-图搜索/</id>
    <published>2016-01-04T02:00:00.000Z</published>
    <updated>2016-03-14T09:29:00.079Z</updated>
    
    <content type="html">&lt;h1 id=&quot;图搜索策略简介&quot;&gt;&lt;a href=&quot;#图搜索策略简介&quot; class=&quot;headerlink&quot; title=&quot;图搜索策略简介&quot;&gt;&lt;/a&gt;图搜索策略简介&lt;/h1&gt;&lt;p&gt;之前所说的&lt;a href=&quot;http://buptldy.github.io/2016/01/03/%E5%9B%9E%E6%BA%AF%E7%AD%96%E7%95%A5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;回溯搜索策略&lt;/a&gt;是只保留了从初始状态到当前状态的一条路径，优点是节省存储空间，缺点是被回溯掉的已经搜索过的部分不能再使用。 与之相对应的是，将所有搜索过的状态都记录下来的搜索方法称为“图搜索”。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;图搜索实际上是从一个隐含图中生成一部分确实含有一个目标结点的显示表示子图的搜索过程。&lt;/p&gt;
&lt;p&gt;扩展一个结点：应用规则到已有结点上，生成其&lt;strong&gt;所有&lt;/strong&gt;后继扩展结点的过程。扩展节点可使定义的隐含图生成为显式表示的状态空间图。&lt;/p&gt;
&lt;h1 id=&quot;2-图搜索算法&quot;&gt;&lt;a href=&quot;#2-图搜索算法&quot; class=&quot;headerlink&quot; title=&quot;2. 图搜索算法&quot;&gt;&lt;/a&gt;2. 图搜索算法&lt;/h1&gt;&lt;p&gt;图搜索中的两个表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- OPEN表：存放已经生成但未扩展的节点，最初只含初始结点
- CLOSED表：存放已经扩展的节点，其实设置为空表
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;图搜索过程：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/7EvIIuk.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法结束后，将生成一个图G，称为搜索图。同时由于每个节点都有一个指针指向父节点，这些指针指向的节点构成G的一个支撑树，称为搜索树。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从目标节点开始，将指针指向的状态回串起来，即找到一条解路径。&lt;/p&gt;
&lt;p&gt;例子：&lt;br&gt;下图中S结点为初始结点，把结点S放入OPEN表中，从S结点开始扩展，生成S结点的所有后继结点｛1，2，3｝，S结点已扩展，加入CLOSED表中，继续这一过程。&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/2g5AKHd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;从上述结果可以看出，最终OPEN表中的结点都是搜索树中的端结点，而CLOSED表中的结点为搜索树中的非端结点。&lt;/p&gt;
&lt;p&gt;对于搜索过程中3中的d）步骤，如果要搜索的隐含图是一棵树，则在它上一步中生成后继结点不可能是以前生成过的，即生成的后继结点不可能出现在OPEN，CLOSED表中，此时搜索图就是搜索树，因此不必进行指针的修改操作。如果要搜索的隐含图不是一棵树，则有可能存在生成的后继结点中的某一结点$m_k$已经在OPEN，CLOSED表中存在,&lt;strong&gt;&lt;em&gt;这意味着此时又发现了达到$m_k$的新通路&lt;/em&gt;&lt;/strong&gt;，这样就需要比较不用路径到达点$m_k$的代价，将指针修改到代价最小的路径上。&lt;/p&gt;
&lt;h1 id=&quot;无信息图搜索过程&quot;&gt;&lt;a href=&quot;#无信息图搜索过程&quot; class=&quot;headerlink&quot; title=&quot;无信息图搜索过程&quot;&gt;&lt;/a&gt;无信息图搜索过程&lt;/h1&gt;&lt;p&gt;无信息搜索过程是在图搜索算法过程中第3点的e）步中排列OPEN表中结点的顺序时，没有使用与问题有关的知识，任意排列，通常有&lt;em&gt;深度优先&lt;/em&gt;和&lt;em&gt;宽度优先&lt;/em&gt;两种排列方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;深度优先&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所谓深度优先搜索就是在每次扩展一个结点时，选择到目前为止深度最深的结点优先扩展。在算法中的实现为：&lt;/p&gt;
&lt;p&gt;把后继结点中不在OPEN或CLOSED中的结点放在OPEN表的最前面，是深度大的结点优先扩展&lt;/p&gt;
&lt;p&gt;因为新扩展出来的结点为子节点，子节点的深度要大于父节点的深度。一般情况下，深度优先搜索不但不能保证找到最优解，也不一定能保证找到解，这取决与问题的状态空间，如果问题的状态空间无限，可能会陷入“深渊”，而找不到解，因此也需要限制搜索的深度。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;问题状态图G2如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/B3dYJla.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据深度优先原则，搜索过程为：（A–&amp;gt;B–&amp;gt;C–&amp;gt;E–&amp;gt;D–&amp;gt;F–&amp;gt;G）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/CrjoNGl.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宽度优先&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;宽度优先搜索与深度优先相反，每次选择深度最浅的结点优先扩展，实现方法为：&lt;/p&gt;
&lt;p&gt;把后继结点中不在OPEN或CLOSED中的结点放在OPEN表的后面&lt;/p&gt;
&lt;p&gt;当问题有解时，宽度优先算大一定能找到解，且在每段路径为单位代价时能找到最优解。&lt;/p&gt;
&lt;p&gt;根据宽度优先原则，对图G2的搜索过程为：（A–&amp;gt;B–&amp;gt;C–&amp;gt;E–&amp;gt;F–&amp;gt;D–&amp;gt;G）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/LLE7pad.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&amp;lt;&amp;lt;人工智能&amp;gt;&amp;gt;.马少平，朱小燕编著&lt;/p&gt;
&lt;p&gt;图的遍历之 深度优先搜索和广度优先搜索:&lt;a href=&quot;http://www.cnblogs.com/skywang12345/p/3711483.html&quot; title=&quot;图的遍历之 深度优先搜索和广度优先搜索&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/skywang12345/p/3711483.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;图搜索策略简介&quot;&gt;&lt;a href=&quot;#图搜索策略简介&quot; class=&quot;headerlink&quot; title=&quot;图搜索策略简介&quot;&gt;&lt;/a&gt;图搜索策略简介&lt;/h1&gt;&lt;p&gt;之前所说的&lt;a href=&quot;http://buptldy.github.io/2016/01/03/%E5%9B%9E%E6%BA%AF%E7%AD%96%E7%95%A5/&quot;&gt;回溯搜索策略&lt;/a&gt;是只保留了从初始状态到当前状态的一条路径，优点是节省存储空间，缺点是被回溯掉的已经搜索过的部分不能再使用。 与之相对应的是，将所有搜索过的状态都记录下来的搜索方法称为“图搜索”。&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Artificial Intelligence" scheme="http://yoursite.com/tags/Artificial-Intelligence/"/>
    
  </entry>
  
  <entry>
    <title>回溯策略[backtracking]</title>
    <link href="http://yoursite.com/2016/01/03/2016-01-03-%E5%9B%9E%E6%BA%AF%E7%AD%96%E7%95%A5/"/>
    <id>http://yoursite.com/2016/01/03/2016-01-03-回溯策略/</id>
    <published>2016-01-03T02:00:00.000Z</published>
    <updated>2016-03-14T09:30:39.408Z</updated>
    
    <content type="html">&lt;h1 id=&quot;回溯策略（backtracking）简介&quot;&gt;&lt;a href=&quot;#回溯策略（backtracking）简介&quot; class=&quot;headerlink&quot; title=&quot;回溯策略（backtracking）简介&quot;&gt;&lt;/a&gt;回溯策略（backtracking）简介&lt;/h1&gt;&lt;p&gt;回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;    - 找到一个可能存在的正确的答案&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在尝试了所有可能的分步方法后宣告该问题没有答案&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。&lt;/p&gt;
&lt;h1 id=&quot;回溯策略应用：四皇后问题（Four-queens-puzzle）&quot;&gt;&lt;a href=&quot;#回溯策略应用：四皇后问题（Four-queens-puzzle）&quot; class=&quot;headerlink&quot; title=&quot;回溯策略应用：四皇后问题（Four queens puzzle）&quot;&gt;&lt;/a&gt;回溯策略应用：四皇后问题（Four queens puzzle）&lt;/h1&gt;&lt;p&gt;四皇后问题：在一个国际象棋中的 的棋盘上放置4个皇后， 为了使其中的任何2个皇后都不能相互“攻击”，希望寻求4个皇后的安全放置位置。 该问题的不能相互“攻击”相当于要求任意两个皇后不能在同一行、同一列或同一斜线上。&lt;/p&gt;
&lt;p&gt;用回溯策略解决这一问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先放第一颗棋子&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/775UH8f.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在符合规则的条件下摆放第二课棋子&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/OYEeASd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在规则下未找到解时，回溯&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/wIxeLH5.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据回溯策略，不断的试探，最终找到解为：&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/f1QnRh3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;回溯搜索中知识的利用&quot;&gt;&lt;a href=&quot;#回溯搜索中知识的利用&quot; class=&quot;headerlink&quot; title=&quot;回溯搜索中知识的利用&quot;&gt;&lt;/a&gt;回溯搜索中知识的利用&lt;/h1&gt;&lt;p&gt;在回溯策略中，可以通过引入一些与问题有关的信息来加快搜索解的速度。对与N皇后问题来说，引入信息的基本思想是：&lt;/p&gt;
&lt;p&gt;尽可能选取划去对角线上位置数最少的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/JCaTEEu.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以想象，如果把一个皇后放在棋盘的某个位置后，它所影响的棋盘位置数少，那么给以后放置皇后剩下的余地就越大，找到解的可能性也越大。&lt;/p&gt;
&lt;h1 id=&quot;回溯算法存在的问题及解决方案&quot;&gt;&lt;a href=&quot;#回溯算法存在的问题及解决方案&quot; class=&quot;headerlink&quot; title=&quot;回溯算法存在的问题及解决方案&quot;&gt;&lt;/a&gt;回溯算法存在的问题及解决方案&lt;/h1&gt;&lt;p&gt;存在的问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 某一个分支具有无穷个状态，算法可能落入“深渊”，永远不能回溯
- 某一个分支上具有环路，搜索在环路中一直进行，同样不能回溯
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决方案：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 对搜索深度进行限制，当当前状态的深度达到了限制深度时，算法将进行回溯
- 记录从初始状态到当前状态的路径，如果出现过此路径，表明出现环路，算法回溯
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;维基百科回溯法：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95&quot; title=&quot;维基百科：回溯法&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://zh.wikipedia.org/wiki/%E5%9B%9E%E6%BA%AF%E6%B3%95&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;四皇后问题：&lt;a href=&quot;http://jpkc.onlinesjtu.com/CourseShare/DataStructure/FlashInteractivePage/exp7.htm&quot; title=&quot;四皇后问题&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://jpkc.onlinesjtu.com/CourseShare/DataStructure/FlashInteractivePage/exp7.htm&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;回溯策略（backtracking）简介&quot;&gt;&lt;a href=&quot;#回溯策略（backtracking）简介&quot; class=&quot;headerlink&quot; title=&quot;回溯策略（backtracking）简介&quot;&gt;&lt;/a&gt;回溯策略（backtracking）简介&lt;/h1&gt;&lt;p&gt;回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问题的答案。回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种情况：&lt;br&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
      <category term="Artificial Intelligence" scheme="http://yoursite.com/tags/Artificial-Intelligence/"/>
    
  </entry>
  
  <entry>
    <title>算法渐进记号及主定理</title>
    <link href="http://yoursite.com/2015/12/29/2015-12-29-%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%B8%90%E8%BF%9B%E6%A0%87%E5%8F%B7/"/>
    <id>http://yoursite.com/2015/12/29/2015-12-29-算法复杂度渐进标号/</id>
    <published>2015-12-29T02:00:00.000Z</published>
    <updated>2016-03-14T09:32:57.208Z</updated>
    
    <content type="html">&lt;h1 id=&quot;算法渐进记号&quot;&gt;&lt;a href=&quot;#算法渐进记号&quot; class=&quot;headerlink&quot; title=&quot;算法渐进记号&quot;&gt;&lt;/a&gt;算法渐进记号&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Big $\Theta$ ：$\Theta$ 记号渐进的给出一个函数的上界和下届，表示同阶的函数簇。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Big $O$：表示一个函数的渐进上界，用来限制算法的最坏情况运行时间。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Big $\Omega$：表示一个函数的渐进下界，算法运行的最好情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Litter $o$: 和big $O$ 定义相似，区别主要是 big$O$ 提供的上界可能和函数是同阶的，litter $o$ 表示非渐进紧确的上界。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;举例&quot;&gt;&lt;a href=&quot;#举例&quot; class=&quot;headerlink&quot; title=&quot;举例&quot;&gt;&lt;/a&gt;举例&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/GgsO2DX.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;渐进记号与函数阶数的关系&quot;&gt;&lt;a href=&quot;#渐进记号与函数阶数的关系&quot; class=&quot;headerlink&quot; title=&quot;渐进记号与函数阶数的关系&quot;&gt;&lt;/a&gt;渐进记号与函数阶数的关系&lt;/h1&gt;&lt;p&gt;其中$a，b$分别为函数$g(n)，f(n)$的阶数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/wUDSXQf.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;通常Big $\Theta$ 用来描述算法的最好和最坏的运行时间，Big $O$描述算法的最坏运行时间，Big $\Omega$描述算法的最好运行时间，经常使用的是Big $O$， 用来衡量算法的时间复杂度和空间复杂度。&lt;/p&gt;
&lt;h1 id=&quot;主定理-master-theorem-求解递归式&quot;&gt;&lt;a href=&quot;#主定理-master-theorem-求解递归式&quot; class=&quot;headerlink&quot; title=&quot;主定理(master theorem)求解递归式&quot;&gt;&lt;/a&gt;主定理(master theorem)求解递归式&lt;/h1&gt;&lt;p&gt;假设有递推关系式&lt;/p&gt;
&lt;p&gt;$$T(n) = a \; T!\left(\frac{n}{b}\right) + f(n)$$&lt;/p&gt;
&lt;p&gt;其中$ a \geq 1 \mbox{, } b &amp;gt; 1$，n为问题规模，a为递推的子问题数量，n/b为每个子问题的规模（假设每个子问题的规模基本一样），f(n)为递推以外进行的计算工作，包含了问题分解和子问题合并的代价。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况一&lt;br&gt;如果存在常数$\epsilon &amp;gt; 0$，有$f(n) = O\left( n^{\log_b (a) - \epsilon} \right)$，并且是多项式意义上的小于，那么&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$T(n) = \Theta\left( n^{\log_b a} \right)$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况二&lt;br&gt;如果存在常数k ≥ 0，有$f(n) = \Theta\left( n^{\log_b a} \log^{k} n \right)$那么&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$T(n) = \Theta\left( n^{\log_b a} \log^{k+1} n \right)$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;情况三&lt;br&gt;如果存在常数$\epsilon &amp;gt; 0$，有$f(n) = \Omega\left( n^{\log_b (a) + \epsilon} \right)$，并且是多项式意义上的大于，同时存在常数c &amp;lt; 1以及充分大的n，满足&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$a f\left( \frac{n}{b} \right) \le c f(n)$$&lt;/p&gt;
&lt;p&gt;那么&lt;/p&gt;
&lt;p&gt;$$T\left(n \right) = \Theta \left(f \left(n \right) \right)$$&lt;/p&gt;
&lt;p&gt;简单举例：&lt;/p&gt;
&lt;p&gt;$$T(n) = 9 \; T!\left(\frac{n}{3}\right) + n$$&lt;/p&gt;
&lt;p&gt;对这个递归式，有a=9,b=3,f(n)=n,因此有$n^{log_b a}=n^2&amp;gt;n$,所以复杂度为：&lt;/p&gt;
&lt;p&gt;$$T(n)=\Theta(n^2)$$&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;算法渐进记号&quot;&gt;&lt;a href=&quot;#算法渐进记号&quot; class=&quot;headerlink&quot; title=&quot;算法渐进记号&quot;&gt;&lt;/a&gt;算法渐进记号&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Big $\Theta$ ：$\Theta$ 记号渐进的给出一个函数的上界和下届，表示同阶的函数簇。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Big $O$：表示一个函数的渐进上界，用来限制算法的最坏情况运行时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://yoursite.com/tags/Algorithms/"/>
    
  </entry>
  
</feed>
